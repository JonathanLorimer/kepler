-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/f-o-a-m/kepler/blob/master/hs-abci-sdk/README.md</a>
@package hs-abci-sdk
@version 0.1.0.0

module Proto.Modules.Auth

-- | Fields :
--   
--   <ul>
--   <li><a>coins</a> <tt>:: Lens' Account [Coin]</tt></li>
--   <li><a>vec'coins</a> <tt>:: Lens' Account (Data.Vector.Vector
--   Coin)</tt></li>
--   <li><a>nonce</a> <tt>:: Lens' Account Data.Word.Word64</tt></li>
--   </ul>
data Account

-- | Fields :
--   
--   <ul>
--   <li><a>amount</a> <tt>:: Lens' Amount Data.Word.Word64</tt></li>
--   </ul>
data Amount

-- | Fields :
--   
--   <ul>
--   <li><a>id</a> <tt>:: Lens' Coin CoinId</tt></li>
--   <li><a>maybe'id</a> <tt>:: Lens' Coin (Prelude.Maybe CoinId)</tt></li>
--   <li><a>amount</a> <tt>:: Lens' Coin Amount</tt></li>
--   <li><a>maybe'amount</a> <tt>:: Lens' Coin (Prelude.Maybe
--   Amount)</tt></li>
--   </ul>
data Coin

-- | Fields :
--   
--   <ul>
--   <li><a>id</a> <tt>:: Lens' CoinId Data.Text.Text</tt></li>
--   </ul>
data CoinId
instance GHC.Classes.Ord Proto.Modules.Auth.Account
instance GHC.Classes.Eq Proto.Modules.Auth.Account
instance GHC.Classes.Ord Proto.Modules.Auth.Coin
instance GHC.Classes.Eq Proto.Modules.Auth.Coin
instance GHC.Classes.Ord Proto.Modules.Auth.CoinId
instance GHC.Classes.Eq Proto.Modules.Auth.CoinId
instance GHC.Classes.Ord Proto.Modules.Auth.Amount
instance GHC.Classes.Eq Proto.Modules.Auth.Amount
instance GHC.Show.Show Proto.Modules.Auth.Account
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Account "coins" [Proto.Modules.Auth.Coin]
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Account "vec'coins" (Data.Vector.Vector Proto.Modules.Auth.Coin)
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Account "nonce" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.Account
instance Control.DeepSeq.NFData Proto.Modules.Auth.Account
instance GHC.Show.Show Proto.Modules.Auth.Coin
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "id" Proto.Modules.Auth.CoinId
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "maybe'id" (GHC.Maybe.Maybe Proto.Modules.Auth.CoinId)
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "amount" Proto.Modules.Auth.Amount
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "maybe'amount" (GHC.Maybe.Maybe Proto.Modules.Auth.Amount)
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.Coin
instance Control.DeepSeq.NFData Proto.Modules.Auth.Coin
instance GHC.Show.Show Proto.Modules.Auth.CoinId
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.CoinId "id" Data.Text.Internal.Text
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.CoinId
instance Control.DeepSeq.NFData Proto.Modules.Auth.CoinId
instance GHC.Show.Show Proto.Modules.Auth.Amount
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Amount "amount" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.Amount
instance Control.DeepSeq.NFData Proto.Modules.Auth.Amount

module Proto.Modules.Auth_Fields
amount :: forall f s a. (Functor f, HasField s "amount" a) => LensLike' f s a
coins :: forall f s a. (Functor f, HasField s "coins" a) => LensLike' f s a
id :: forall f s a. (Functor f, HasField s "id" a) => LensLike' f s a
maybe'amount :: forall f s a. (Functor f, HasField s "maybe'amount" a) => LensLike' f s a
maybe'id :: forall f s a. (Functor f, HasField s "maybe'id" a) => LensLike' f s a
nonce :: forall f s a. (Functor f, HasField s "nonce" a) => LensLike' f s a
vec'coins :: forall f s a. (Functor f, HasField s "vec'coins" a) => LensLike' f s a

module Proto.Modules.Bank

-- | Fields :
--   
--   <ul>
--   <li><a>address</a> <tt>:: Lens' Burn
--   Data.ByteString.ByteString</tt></li>
--   <li><a>cid</a> <tt>:: Lens' Burn Data.Text.Text</tt></li>
--   <li><a>amount</a> <tt>:: Lens' Burn Data.Word.Word64</tt></li>
--   </ul>
data Burn

-- | Fields :
--   
--   <ul>
--   <li><a>to</a> <tt>:: Lens' Transfer
--   Data.ByteString.ByteString</tt></li>
--   <li><a>from</a> <tt>:: Lens' Transfer
--   Data.ByteString.ByteString</tt></li>
--   <li><a>cid</a> <tt>:: Lens' Transfer Data.Text.Text</tt></li>
--   <li><a>amount</a> <tt>:: Lens' Transfer Data.Word.Word64</tt></li>
--   </ul>
data Transfer
instance GHC.Classes.Ord Proto.Modules.Bank.Transfer
instance GHC.Classes.Eq Proto.Modules.Bank.Transfer
instance GHC.Classes.Ord Proto.Modules.Bank.Burn
instance GHC.Classes.Eq Proto.Modules.Bank.Burn
instance GHC.Show.Show Proto.Modules.Bank.Transfer
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Transfer "to" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Transfer "from" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Transfer "cid" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Transfer "amount" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Bank.Transfer
instance Control.DeepSeq.NFData Proto.Modules.Bank.Transfer
instance GHC.Show.Show Proto.Modules.Bank.Burn
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Burn "address" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Burn "cid" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Burn "amount" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Bank.Burn
instance Control.DeepSeq.NFData Proto.Modules.Bank.Burn

module Proto.Modules.Bank_Fields
address :: forall f s a. (Functor f, HasField s "address" a) => LensLike' f s a
amount :: forall f s a. (Functor f, HasField s "amount" a) => LensLike' f s a
cid :: forall f s a. (Functor f, HasField s "cid" a) => LensLike' f s a
from :: forall f s a. (Functor f, HasField s "from" a) => LensLike' f s a
to :: forall f s a. (Functor f, HasField s "to" a) => LensLike' f s a

module Proto.Types.Transaction

-- | Fields :
--   
--   <ul>
--   <li><a>data'</a> <tt>:: Lens' RawTransaction TypedMessage</tt></li>
--   <li><a>maybe'data'</a> <tt>:: Lens' RawTransaction (Prelude.Maybe
--   TypedMessage)</tt></li>
--   <li><a>gas</a> <tt>:: Lens' RawTransaction Data.Int.Int64</tt></li>
--   <li><a>signature</a> <tt>:: Lens' RawTransaction
--   Data.ByteString.ByteString</tt></li>
--   <li><a>route</a> <tt>:: Lens' RawTransaction Data.Text.Text</tt></li>
--   <li><a>nonce</a> <tt>:: Lens' RawTransaction
--   Data.Word.Word64</tt></li>
--   </ul>
data RawTransaction

-- | Fields :
--   
--   <ul>
--   <li><a>type'</a> <tt>:: Lens' TypedMessage Data.Text.Text</tt></li>
--   <li><a>data'</a> <tt>:: Lens' TypedMessage
--   Data.ByteString.ByteString</tt></li>
--   </ul>
data TypedMessage
instance GHC.Classes.Ord Proto.Types.Transaction.RawTransaction
instance GHC.Classes.Eq Proto.Types.Transaction.RawTransaction
instance GHC.Classes.Ord Proto.Types.Transaction.TypedMessage
instance GHC.Classes.Eq Proto.Types.Transaction.TypedMessage
instance GHC.Show.Show Proto.Types.Transaction.RawTransaction
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "data'" Proto.Types.Transaction.TypedMessage
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "maybe'data'" (GHC.Maybe.Maybe Proto.Types.Transaction.TypedMessage)
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "gas" GHC.Int.Int64
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "signature" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "route" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "nonce" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Types.Transaction.RawTransaction
instance Control.DeepSeq.NFData Proto.Types.Transaction.RawTransaction
instance GHC.Show.Show Proto.Types.Transaction.TypedMessage
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.TypedMessage "type'" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.TypedMessage "data'" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Message.Message Proto.Types.Transaction.TypedMessage
instance Control.DeepSeq.NFData Proto.Types.Transaction.TypedMessage

module Proto.Types.Transaction_Fields
data' :: forall f s a. (Functor f, HasField s "data'" a) => LensLike' f s a
gas :: forall f s a. (Functor f, HasField s "gas" a) => LensLike' f s a
maybe'data' :: forall f s a. (Functor f, HasField s "maybe'data'" a) => LensLike' f s a
nonce :: forall f s a. (Functor f, HasField s "nonce" a) => LensLike' f s a
route :: forall f s a. (Functor f, HasField s "route" a) => LensLike' f s a
signature :: forall f s a. (Functor f, HasField s "signature" a) => LensLike' f s a
type' :: forall f s a. (Functor f, HasField s "type'" a) => LensLike' f s a

module Tendermint.SDK.BaseApp.Logger

-- | Effect allowing for console logging.
data Logger m a
[Log] :: Severity -> Text -> Logger m ()
[AddContext] :: (Select x, ToJSON x) => x -> m a -> Logger m a
log :: forall r_aEAt. MemberWithError Logger r_aEAt => Severity -> Text -> Sem r_aEAt ()

-- | Class for selecting object keys for contextual logging
class Select a
select :: Select a => Verbosity -> a -> LogSelect
select :: Select a => Verbosity -> a -> LogSelect
addContext :: forall r_aEAw x_XDgm a_aDgn. (MemberWithError Logger r_aEAw, Select x_XDgm, ToJSON x_XDgm) => x_XDgm -> Sem r_aEAw a_aDgn -> Sem r_aEAw a_aDgn
data LogSelect
All :: LogSelect
Some :: [Text] -> LogSelect
data Severity
Debug :: Severity
Info :: Severity
Warning :: Severity
Error :: Severity
Exception :: Severity
data Verbosity
V0 :: Verbosity
V1 :: Verbosity
V2 :: Verbosity
V3 :: Verbosity
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Logger.Severity
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Logger.Severity

module Tendermint.SDK.BaseApp.Logger.Katip
data LogConfig
LogConfig :: Namespace -> LogContexts -> LogEnv -> LogConfig
[_logNamespace] :: LogConfig -> Namespace
[_logContext] :: LogConfig -> LogContexts
[_logEnv] :: LogConfig -> LogEnv
logNamespace :: Lens' LogConfig Namespace
logContext :: Lens' LogConfig LogContexts
logEnv :: Lens' LogConfig LogEnv
data InitialLogNamespace
InitialLogNamespace :: Text -> Text -> InitialLogNamespace
[_initialLogEnvironment] :: InitialLogNamespace -> Text
[_initialLogProcessName] :: InitialLogNamespace -> Text
initialLogEnvironment :: Lens' InitialLogNamespace Text
initialLogProcessName :: Lens' InitialLogNamespace Text
evalKatip :: forall r a. KatipContext (Sem r) => Sem (Logger : r) a -> Sem r a
instance Polysemy.Internal.Members '[Polysemy.Embed.Type.Embed GHC.Types.IO, Polysemy.Reader.Reader Tendermint.SDK.BaseApp.Logger.Katip.LogConfig] r => Katip.Core.Katip (Polysemy.Internal.Sem r)
instance Polysemy.Internal.Members '[Polysemy.Embed.Type.Embed GHC.Types.IO, Polysemy.Reader.Reader Tendermint.SDK.BaseApp.Logger.Katip.LogConfig] r => Katip.Monadic.KatipContext (Polysemy.Internal.Sem r)
instance Tendermint.SDK.BaseApp.Logger.Select a => Tendermint.SDK.BaseApp.Logger.Select (Tendermint.SDK.BaseApp.Logger.Katip.Object a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Katip.Core.ToObject (Tendermint.SDK.BaseApp.Logger.Katip.Object a)
instance (Data.Aeson.Types.ToJSON.ToJSON a, Tendermint.SDK.BaseApp.Logger.Select a) => Katip.Core.LogItem (Tendermint.SDK.BaseApp.Logger.Katip.Object a)

module Tendermint.SDK.BaseApp.Metrics
data CountName
CountName :: Text -> [(Text, Text)] -> CountName
[countName] :: CountName -> Text
[countLabels] :: CountName -> [(Text, Text)]
data HistogramName
HistogramName :: Text -> [(Text, Text)] -> [Double] -> HistogramName
[histogramName] :: HistogramName -> Text
[histogramLabels] :: HistogramName -> [(Text, Text)]
[histogramBuckets] :: HistogramName -> [Double]
data Metrics m a

-- | Increments the count of a specific message
[IncCount] :: CountName -> Metrics m ()

-- | Times an action and records it in a histogram
[WithTimer] :: HistogramName -> m a -> Metrics m a
withTimer :: forall r_aNv7 a_aNng. MemberWithError Metrics r_aNv7 => HistogramName -> Sem r_aNv7 a_aNng -> Sem r_aNv7 a_aNng
incCount :: forall r_aNv5. MemberWithError Metrics r_aNv5 => CountName -> Sem r_aNv5 ()
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Metrics.HistogramName
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Metrics.HistogramName
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Metrics.CountName
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Metrics.CountName
instance Data.String.IsString Tendermint.SDK.BaseApp.Metrics.HistogramName
instance Data.String.IsString Tendermint.SDK.BaseApp.Metrics.CountName

module Tendermint.SDK.BaseApp.Metrics.Prometheus

-- | Core metrics config
data MetricsScrapingConfig
MetricsScrapingConfig :: Int -> MetricsScrapingConfig
[_prometheusPort] :: MetricsScrapingConfig -> Int
prometheusPort :: Iso' MetricsScrapingConfig Int
data MetricsState
MetricsState :: Registry -> MVar (MetricsMap Counter) -> MVar (MetricsMap Histogram) -> MetricsState
[_metricsRegistry] :: MetricsState -> Registry
[_metricsCounters] :: MetricsState -> MVar (MetricsMap Counter)
[_metricsHistograms] :: MetricsState -> MVar (MetricsMap Histogram)
metricsRegistry :: Lens' MetricsState Registry
metricsCounters :: Lens' MetricsState (MVar (MetricsMap Counter))
metricsHistograms :: Lens' MetricsState (MVar (MetricsMap Histogram))
data PrometheusEnv
PrometheusEnv :: MetricsState -> MetricsScrapingConfig -> PrometheusEnv
[_envMetricsState] :: PrometheusEnv -> MetricsState
[_envMetricsScrapingConfig] :: PrometheusEnv -> MetricsScrapingConfig
envMetricsState :: Lens' PrometheusEnv MetricsState
envMetricsScrapingConfig :: Lens' PrometheusEnv MetricsScrapingConfig
emptyState :: IO MetricsState
forkMetricsServer :: MonadIO m => PrometheusEnv -> m ThreadId

-- | Prometheus registry index key
mkPrometheusMetricId :: MetricIdentifier -> MetricId

-- | Index key for storing metrics
metricIdStorable :: MetricIdentifier -> (Text, Labels)
countToIdentifier :: CountName -> MetricIdentifier
histogramToIdentifier :: HistogramName -> MetricIdentifier
evalWithMetrics :: Member (Embed IO) r => Member (Reader (Maybe PrometheusEnv)) r => Sem (Metrics : r) a -> Sem r a
evalNothing :: Sem (Metrics : r) a -> Sem r a

-- | Increments existing count, if it doesn't exist, creates a new |
--   counter and increments it.
evalMetrics :: Member (Embed IO) r => MetricsState -> Sem (Metrics : r) a -> Sem r a
instance Data.String.IsString Tendermint.SDK.BaseApp.Metrics.Prometheus.MetricIdentifier

module Tendermint.SDK.Codec

-- | This class is used as a codec for all items stored in | the database
--   as well as incoming transaction messages.
class HasCodec a
encode :: HasCodec a => a -> ByteString
decode :: HasCodec a => ByteString -> Either Text a
defaultSDKAesonOptions :: String -> Options
instance Tendermint.SDK.Codec.HasCodec ()
instance Tendermint.SDK.Codec.HasCodec GHC.Word.Word32
instance Tendermint.SDK.Codec.HasCodec GHC.Int.Int32
instance Tendermint.SDK.Codec.HasCodec GHC.Word.Word64
instance Tendermint.SDK.Codec.HasCodec GHC.Int.Int64
instance Tendermint.SDK.Codec.HasCodec GHC.Base.String
instance Tendermint.SDK.Codec.HasCodec Data.Text.Internal.Text
instance Tendermint.SDK.Codec.HasCodec Data.ByteString.Internal.ByteString

module Tendermint.SDK.BaseApp.Events

-- | A class representing a type that can be emitted as an event in the |
--   event logs for the deliverTx response.
class ToEvent e
toEvent :: ToEvent e => e -> Event
toEvent :: (ToEvent e, Generic e, GToEvent (Rep e)) => e -> Event

-- | Special event wrapper to add contextual event_type info
newtype ContextEvent t
ContextEvent :: t -> ContextEvent t
emit :: ToEvent e => Member (Output Event) r => e -> Sem r ()
logEvent :: forall e r. (ToJSON e, ToEvent e, Select e) => Member Logger r => e -> Sem r ()
data Event
Event :: Text -> [KVPair] -> Event

-- | Type of Event
[eventType] :: Event -> Text

-- | Event attributes
[eventAttributes] :: Event -> [KVPair]
instance (Data.Aeson.Types.ToJSON.ToJSON a, Tendermint.SDK.BaseApp.Events.ToEvent a) => Data.Aeson.Types.ToJSON.ToJSON (Tendermint.SDK.BaseApp.Events.ContextEvent a)
instance Tendermint.SDK.BaseApp.Logger.Select a => Tendermint.SDK.BaseApp.Logger.Select (Tendermint.SDK.BaseApp.Events.ContextEvent a)
instance forall k (f :: k -> *) (d :: GHC.Generics.Meta). (Tendermint.SDK.BaseApp.Events.GToNamedEventPrimatives f, GHC.Generics.Datatype d) => Tendermint.SDK.BaseApp.Events.GToEvent (GHC.Generics.D1 d f)
instance forall k (f :: k -> *) (c :: GHC.Generics.Meta). Tendermint.SDK.BaseApp.Events.GToNamedEventPrimatives f => Tendermint.SDK.BaseApp.Events.GToNamedEventPrimatives (GHC.Generics.C1 c f)
instance (GHC.Generics.Selector s, Tendermint.SDK.Codec.HasCodec a) => Tendermint.SDK.BaseApp.Events.GToNamedEventPrimatives (GHC.Generics.S1 s (GHC.Generics.K1 i a))
instance forall k (a :: k -> *) (b :: k -> *). (Tendermint.SDK.BaseApp.Events.GToNamedEventPrimatives a, Tendermint.SDK.BaseApp.Events.GToNamedEventPrimatives b) => Tendermint.SDK.BaseApp.Events.GToNamedEventPrimatives (a GHC.Generics.:*: b)

module Tendermint.SDK.Types.Address

-- | Used as a unique identifier for an account.
newtype Address
Address :: HexString -> Address
addressToBytes :: Address -> ByteString
addressFromBytes :: ByteString -> Address
pubKeyToAddress :: PubKey -> Address
instance Data.Aeson.Types.FromJSON.FromJSON Tendermint.SDK.Types.Address.Address
instance Data.Aeson.Types.ToJSON.ToJSON Tendermint.SDK.Types.Address.Address
instance GHC.Classes.Ord Tendermint.SDK.Types.Address.Address
instance GHC.Generics.Generic Tendermint.SDK.Types.Address.Address
instance GHC.Show.Show Tendermint.SDK.Types.Address.Address
instance GHC.Classes.Eq Tendermint.SDK.Types.Address.Address
instance Proto3.Suite.Class.Primitive Tendermint.SDK.Types.Address.Address
instance Proto3.Suite.Class.HasDefault Tendermint.SDK.Types.Address.Address
instance Proto3.Suite.Class.MessageField Tendermint.SDK.Types.Address.Address
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Types.Address.Address
instance Web.Internal.HttpApiData.ToHttpApiData Tendermint.SDK.Types.Address.Address
instance Web.Internal.HttpApiData.FromHttpApiData Tendermint.SDK.Types.Address.Address
instance Proto3.Suite.Class.HasDefault Data.ByteArray.HexString.HexString

module Tendermint.SDK.Crypto

-- | Class encapsulating data which can hashed.
class MakeDigest a
makeDigest :: MakeDigest a => a -> Digest SHA256

-- | Defines the types and methods for the signature schema parameterized
--   by <tt>alg</tt>.
class SignatureSchema alg where {
    type family PubKey alg :: Type;
    type family PrivateKey alg :: Type;
    type family Signature alg :: Type;
    type family Message alg :: Type;
}
algorithm :: SignatureSchema alg => Proxy alg -> Text
sign :: SignatureSchema alg => Proxy alg -> PrivateKey alg -> Message alg -> Signature alg
verify :: SignatureSchema alg => Proxy alg -> PubKey alg -> Signature alg -> Message alg -> Bool
makePubKey :: SignatureSchema alg => Proxy alg -> ByteString -> Maybe (PubKey alg)
makeSignature :: SignatureSchema alg => Proxy alg -> ByteString -> Maybe (Signature alg)
derivePubKey :: SignatureSchema alg => Proxy alg -> PrivateKey alg -> PubKey alg
addressFromPubKey :: SignatureSchema alg => Proxy alg -> PubKey alg -> Address

-- | Class allowing for signing and recovering signatures for messages.
class SignatureSchema alg => RecoverableSignatureSchema alg where {
    type family RecoverableSignature alg :: Type;
}
signRecoverableMessage :: RecoverableSignatureSchema alg => Proxy alg -> PrivateKey alg -> Message alg -> RecoverableSignature alg
recover :: RecoverableSignatureSchema alg => Proxy alg -> RecoverableSignature alg -> Message alg -> Maybe (PubKey alg)
serializeRecoverableSignature :: RecoverableSignatureSchema alg => Proxy alg -> RecoverableSignature alg -> ByteString
makeRecoverableSignature :: RecoverableSignatureSchema alg => Proxy alg -> ByteString -> Maybe (RecoverableSignature alg)
parsePubKey :: SignatureSchema alg => Proxy alg -> PubKey -> Either Text (PubKey alg)
data Secp256k1
instance Tendermint.SDK.Crypto.SignatureSchema Tendermint.SDK.Crypto.Secp256k1
instance Tendermint.SDK.Crypto.RecoverableSignatureSchema Tendermint.SDK.Crypto.Secp256k1

module Tendermint.SDK.Types.Effects

-- | This type family gives a nice syntax for combining multiple lists of
--   effects.
type family (as :: [a]) :& (bs :: [a]) :: [a]
infixr 5 :&

module Tendermint.SDK.Types.Message

-- | The basic message format embedded in any transaction.
data Msg msg
Msg :: Address -> msg -> Text -> Msg msg
[msgAuthor] :: Msg msg -> Address
[msgData] :: Msg msg -> msg
[msgType] :: Msg msg -> Text
class HasMessageType msg
messageType :: HasMessageType msg => Proxy msg -> Text
data TypedMessage
TypedMessage :: ByteString -> Text -> TypedMessage
[typedMsgData] :: TypedMessage -> ByteString
[typedMsgType] :: TypedMessage -> Text

-- | This is a general error type, primarily accomodating protobuf messages
--   being parsed | by either the <a>proto3-wire</a> | or the
--   <a>proto-lens</a> libraries.
data MessageParseError

-- | A <a>WireTypeError</a> occurs when the type of the data in the
--   protobuf binary format does not match the type encountered by the
--   parser.
WireTypeError :: Text -> MessageParseError

-- | A <a>BinaryError</a> occurs when we can't successfully parse the
--   contents of the field.
BinaryError :: Text -> MessageParseError

-- | An <a>EmbeddedError</a> occurs when we encounter an error while
--   parsing an embedded message.
EmbeddedError :: Text -> Maybe MessageParseError -> MessageParseError

-- | Unknown or unstructured parsing error.
OtherParseError :: Text -> MessageParseError

-- | Useful for returning in error logs or console logging.
formatMessageParseError :: MessageParseError -> Text
coerceProto3Error :: ParseError -> MessageParseError
coerceProtoLensError :: String -> MessageParseError

-- | Used during message validation to indicate that although the message
--   has parsed | correctly, it fails certain sanity checks.
data MessageSemanticError

-- | Used to indicate that the message signer does not have the authority
--   to send | this message.
PermissionError :: Text -> MessageSemanticError

-- | Used to indicate that a field isn't valid, e.g. enforces non-negative
--   quantities | or nonempty lists.
InvalidFieldError :: Text -> MessageSemanticError
OtherSemanticError :: Text -> MessageSemanticError
formatMessageSemanticError :: MessageSemanticError -> Text
class ValidateMessage msg
validateMessage :: ValidateMessage msg => Msg msg -> Validation [MessageSemanticError] ()
nonEmptyCheck :: Eq a => Monoid a => Text -> a -> Validation [MessageSemanticError] ()
isAuthorCheck :: Text -> Msg msg -> (msg -> Address) -> Validation [MessageSemanticError] ()
instance Control.Lens.Wrapped.Wrapped Tendermint.SDK.Types.Message.TypedMessage
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Types.Message.TypedMessage
instance GHC.Base.Functor Tendermint.SDK.Types.Message.Msg

module Tendermint.SDK.Types.Transaction
data Tx alg msg
Tx :: Msg msg -> Text -> Int64 -> RecoverableSignature alg -> Message alg -> PubKey alg -> Word64 -> Tx alg msg
[txMsg] :: Tx alg msg -> Msg msg
[txRoute] :: Tx alg msg -> Text
[txGas] :: Tx alg msg -> Int64
[txSignature] :: Tx alg msg -> RecoverableSignature alg
[txSignBytes] :: Tx alg msg -> Message alg
[txSigner] :: Tx alg msg -> PubKey alg
[txNonce] :: Tx alg msg -> Word64

-- | Raw transaction type coming in over the wire
data RawTransaction
RawTransaction :: TypedMessage -> Int64 -> Text -> ByteString -> Word64 -> RawTransaction

-- | the encoded message via protobuf encoding
[rawTransactionData] :: RawTransaction -> TypedMessage
[rawTransactionGas] :: RawTransaction -> Int64

-- | module name
[rawTransactionRoute] :: RawTransaction -> Text
[rawTransactionSignature] :: RawTransaction -> ByteString
[rawTransactionNonce] :: RawTransaction -> Word64
signRawTransaction :: forall alg. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => Proxy alg -> PrivateKey alg -> RawTransaction -> RecoverableSignature alg

-- | Attempt to parse a Bytestring into a <a>RawTransaction</a> then as a
--   <a>Tx</a> without | attempting to parse the underlying message. This
--   is done as a preprocessing | step to the router, allowing for failure
--   before the router is ever | reached.
parseTx :: forall alg. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => Proxy alg -> ByteString -> Either Text (Tx alg ByteString)
instance GHC.Generics.Generic Tendermint.SDK.Types.Transaction.RawTransaction
instance Control.Lens.Wrapped.Wrapped Tendermint.SDK.Types.Transaction.RawTransaction
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Types.Transaction.RawTransaction
instance Tendermint.SDK.Crypto.MakeDigest Tendermint.SDK.Types.Transaction.RawTransaction
instance forall k (alg :: k). GHC.Base.Functor (Tendermint.SDK.Types.Transaction.Tx alg)

module Tendermint.SDK.Types.TxResult

-- | This type represents a common transaction result for the CheckTx | and
--   DeliverTx abci-messages.
data TxResult
TxResult :: Base64String -> Text -> Int64 -> Int64 -> [Event] -> Word32 -> Text -> Text -> TxResult
[_txResultData] :: TxResult -> Base64String
[_txResultInfo] :: TxResult -> Text
[_txResultGasWanted] :: TxResult -> Int64
[_txResultGasUsed] :: TxResult -> Int64
[_txResultEvents] :: TxResult -> [Event]
[_txResultCode] :: TxResult -> Word32
[_txResultLog] :: TxResult -> Text
[_txResultCodespace] :: TxResult -> Text
txResultLog :: Lens' TxResult Text
txResultInfo :: Lens' TxResult Text
txResultGasWanted :: Lens' TxResult Int64
txResultGasUsed :: Lens' TxResult Int64
txResultEvents :: Lens' TxResult [Event]
txResultData :: Lens' TxResult Base64String
txResultCodespace :: Lens' TxResult Text
txResultCode :: Lens' TxResult Word32

-- | This class is used to set the <a>TxResult</a> data into the
--   appropriate | response fields for the CheckTx abci-message.
checkTxTxResult :: Iso' CheckTx TxResult

-- | This class is used to set the <a>TxResult</a> data into the
--   appropriate | response fields for the DeliverTx abci-message.
deliverTxTxResult :: Iso' DeliverTx TxResult
instance Data.Default.Class.Default Tendermint.SDK.Types.TxResult.TxResult
instance GHC.Show.Show Tendermint.SDK.Types.TxResult.TxResult

module Tendermint.SDK.BaseApp.Errors

-- | This type represents a common error response for the query, checkTx, |
--   and deliver tx abci-messages.
data AppError
AppError :: Word32 -> Text -> Text -> AppError
[appErrorCode] :: AppError -> Word32
[appErrorCodespace] :: AppError -> Text
[appErrorMessage] :: AppError -> Text

-- | Allows for custom application error types to be coerced into the
--   standard error resposne.
class IsAppError e
makeAppError :: IsAppError e => e -> AppError

-- | This lens is used to set the <a>AppError</a> data into the appropriate
--   | response fields for the query abci-message.
queryAppError :: Lens' Query AppError

-- | This lens is used to set the <a>AppError</a> data into the appropriate
--   | response fields for the checkTx/deliverTx abci-message.
txResultAppError :: Lens' TxResult AppError

-- | These errors originate from the SDK itself. The "sdk" namespace is
--   reserved | for this error type and should not be used in modules or
--   applications.
data SDKError

-- | Something went wrong and we have no idea what.
InternalError :: Text -> SDKError

-- | Parsing errors for SDK specific types, e.g. <tt>RawTransaction</tt> or
--   <tt>Msg</tt>, etc.
ParseError :: Text -> SDKError

-- | The name of the route that failed to match.
UnmatchedRoute :: Text -> SDKError
OutOfGasException :: SDKError
MessageValidation :: [Text] -> SDKError
SignatureRecoveryError :: Text -> SDKError
NonceException :: Word64 -> Word64 -> SDKError
StoreError :: Text -> SDKError
GrpcError :: Text -> SDKError
UnknownAccountError :: Address -> SDKError

-- | As of right now it's not expected that one can recover from an
--   <a>SDKError</a>, | so we are throwing them as <a>AppError</a>s
--   directly.
throwSDKError :: Member (Error AppError) r => SDKError -> Sem r a
instance GHC.Show.Show Tendermint.SDK.BaseApp.Errors.SDKError
instance GHC.Generics.Generic Tendermint.SDK.BaseApp.Errors.AppError
instance GHC.Show.Show Tendermint.SDK.BaseApp.Errors.AppError
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Errors.AppError
instance Tendermint.SDK.BaseApp.Errors.IsAppError Tendermint.SDK.BaseApp.Errors.SDKError
instance GHC.Exception.Type.Exception Tendermint.SDK.BaseApp.Errors.AppError
instance Data.Aeson.Types.ToJSON.ToJSON Tendermint.SDK.BaseApp.Errors.AppError
instance Data.Aeson.Types.FromJSON.FromJSON Tendermint.SDK.BaseApp.Errors.AppError

module Tendermint.SDK.BaseApp.Store.RawStore
type StoreEffs = [Tagged 'Consensus ReadStore, Tagged 'QueryAndMempool ReadStore, Tagged 'Consensus WriteStore, Transaction, CommitBlock]

-- | Store Effects
data Scope
Consensus :: Scope
QueryAndMempool :: Scope

-- | Read and Write Effects
data ReadStore m a
[StoreGet] :: StoreKey -> ReadStore m (Maybe ByteString)
[StoreProve] :: StoreKey -> ReadStore m (Maybe ByteString)
storeGet :: forall r_a1guz. MemberWithError ReadStore r_a1guz => StoreKey -> Sem r_a1guz (Maybe ByteString)
get :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Members [ReadStore, Error AppError] r => Store ns -> k -> Sem r (Maybe (Value k ns))
prove :: forall k ns r. IsKey k ns => Member ReadStore r => Store ns -> k -> Sem r (Maybe ByteString)
data WriteStore m a
[StorePut] :: StoreKey -> ByteString -> WriteStore m ()
[StoreDelete] :: StoreKey -> WriteStore m ()
put :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Member WriteStore r => Store ns -> k -> Value k ns -> Sem r ()
storePut :: forall r_a1gy6. MemberWithError WriteStore r_a1gy6 => StoreKey -> ByteString -> Sem r_a1gy6 ()
delete :: forall k ns r. IsKey k ns => Member WriteStore r => Store ns -> k -> Sem r ()
storeDelete :: forall r_a1gy9. MemberWithError WriteStore r_a1gy9 => StoreKey -> Sem r_a1gy9 ()

-- | Consensus Effects
data CommitBlock m a
[CommitBlock] :: CommitBlock m Base64String
commitBlock :: forall r_a1gGT. MemberWithError CommitBlock r_a1gGT => Sem r_a1gGT Base64String
data Transaction m a
[BeginTransaction] :: Transaction m ()
[Rollback] :: Transaction m ()
[Commit] :: Transaction m CommitResponse
beginTransaction :: forall r_a1gLr. MemberWithError Transaction r_a1gLr => Sem r_a1gLr ()
withSandbox :: forall r a. Members [Transaction, Resource, Error AppError] r => Sem r a -> Sem r a
withTransaction :: forall r a. Members [Transaction, Resource, Error AppError] r => Sem r a -> Sem r (a, CommitResponse)
commit :: forall r_a1gLt. MemberWithError Transaction r_a1gLt => Sem r_a1gLt CommitResponse

-- | Keys
class RawKey k
rawKey :: RawKey k => Iso' k ByteString
class RawKey k => IsKey k ns where {
    type family Value k ns :: Type;
}
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
data StoreKey
StoreKey :: [ByteString] -> ByteString -> StoreKey
[skPathFromRoot] :: StoreKey -> [ByteString]
[skKey] :: StoreKey -> ByteString

-- | Store
newtype KeyRoot ns
KeyRoot :: ByteString -> KeyRoot ns
makeKeyBytes :: StoreKey -> ByteString
data CommitResponse
CommitResponse :: Base64String -> Natural -> CommitResponse
[rootHash] :: CommitResponse -> Base64String
[newVersion] :: CommitResponse -> Natural
data Store ns
nestStore :: Store parentns -> Store childns -> Store childns
makeStore :: KeyRoot ns -> Store ns
makeStoreKey :: forall k ns. IsKey k ns => Store ns -> k -> StoreKey
data Version
Genesis :: Version
Version :: Natural -> Version
Latest :: Version
instance GHC.Show.Show Tendermint.SDK.BaseApp.Store.RawStore.Version
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Store.RawStore.Version
instance GHC.Show.Show Tendermint.SDK.BaseApp.Store.RawStore.CommitResponse
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Store.RawStore.CommitResponse
instance forall k (ns :: k). GHC.Show.Show (Tendermint.SDK.BaseApp.Store.RawStore.KeyRoot ns)
instance forall k (ns :: k). GHC.Classes.Eq (Tendermint.SDK.BaseApp.Store.RawStore.KeyRoot ns)
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Store.RawStore.StoreKey
instance GHC.Show.Show Tendermint.SDK.BaseApp.Store.RawStore.StoreKey
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Store.RawStore.StoreKey
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Data.Text.Internal.Text
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Tendermint.SDK.Types.Address.Address
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey GHC.Word.Word64
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey ()

module Tendermint.SDK.BaseApp.Transaction.Cache
data Cache
emptyCache :: Cache
writeCache :: Member (Tagged 'Consensus WriteStore) r => Cache -> Sem r ()
data Deleted
Deleted :: Deleted
put :: StoreKey -> ByteString -> Cache -> Cache
get :: StoreKey -> Cache -> Either Deleted (Maybe ByteString)
delete :: StoreKey -> Cache -> Cache
instance GHC.Show.Show Tendermint.SDK.BaseApp.Transaction.Cache.Cache
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Transaction.Cache.Cache

module Tendermint.SDK.BaseApp.Store.Var
data Var (a :: Type)
makeVar :: IsKey k ns => Value k ns ~ Var a => k -> Store ns -> Value k ns
makeFullStoreKey :: Var a -> StoreKey
takeVar :: Members [ReadStore, Error AppError] r => HasCodec a => Var a -> Sem r (Maybe a)
unsafeTakeVar :: Members [ReadStore, Error AppError] r => HasCodec a => Var a -> Sem r a
putVar :: Member WriteStore r => HasCodec a => a -> Var a -> Sem r ()
deleteVar :: Member WriteStore r => Var a -> Sem r ()
instance Tendermint.SDK.BaseApp.Store.RawStore.IsKey () (Tendermint.SDK.BaseApp.Store.Var.Var a)

module Tendermint.SDK.BaseApp.Store.MemoryStore
data DBVersions
DBVersions :: IORef Version -> IORef Version -> DBVersions
[latest] :: DBVersions -> IORef Version
[committed] :: DBVersions -> IORef Version
initDBVersions :: IO DBVersions
data DB
initDB :: IO DB
evalStoreEffs :: Members [Embed IO, Reader DBVersions, Reader DB] r => forall a. Sem (StoreEffs :& r) a -> Sem r a
evalRead :: Member (Embed IO) r => DB -> IORef Version -> forall a. Sem (ReadStore : r) a -> Sem r a
evalWrite :: Member (Embed IO) r => DB -> forall a. Sem (WriteStore : r) a -> Sem r a
instance Crypto.Data.Auth.Tree.Class.MerkleHash Tendermint.SDK.BaseApp.Store.MemoryStore.AuthTreeHash

module Tendermint.SDK.BaseApp.Store

module Tendermint.SDK.BaseApp.Store.Map
data Map (k :: Type) (v :: Type)
makeMap :: IsKey key ns => Value key ns ~ Map k v => key -> Store ns -> Value key ns
makeFullStoreKey :: RawKey k => Map k v -> k -> StoreKey
insert :: Member WriteStore r => RawKey k => HasCodec v => k -> v -> Map k v -> Sem r ()
lookup :: Members [Error AppError, ReadStore] r => RawKey k => HasCodec v => k -> Map k v -> Sem r (Maybe v)
delete :: Member WriteStore r => RawKey k => k -> Map k v -> Sem r ()
update :: Members [Error AppError, ReadStore, WriteStore] r => RawKey k => HasCodec v => (v -> Maybe v) -> k -> Map k v -> Sem r ()
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey k => Tendermint.SDK.BaseApp.Store.RawStore.IsKey k (Tendermint.SDK.BaseApp.Store.Map.Map k v)

module Tendermint.SDK.BaseApp.Store.List
data List (a :: Type)
makeList :: IsKey key ns => Value key ns ~ List a => key -> Store ns -> Value key ns
makeFullStoreKey :: List a -> Word64 -> StoreKey
append :: Members [Error AppError, ReadStore, WriteStore] r => HasCodec a => a -> List a -> Sem r ()

-- | Delete the first occurence in the list.
delete :: Members [Error AppError, ReadStore, WriteStore] r => HasCodec a => Eq a => a -> List a -> Sem r ()

-- | Delete an element whenever the predicate evaluates to <a>True</a>
deleteWhen :: Members [Error AppError, ReadStore, WriteStore] r => HasCodec a => (a -> Bool) -> List a -> Sem r ()
foldl :: Members [Error AppError, ReadStore] r => HasCodec a => (b -> a -> b) -> b -> List a -> Sem r b

-- | View the <a>List</a> as a <a>List</a>.
toList :: Members [Error AppError, ReadStore] r => HasCodec a => List a -> Sem r [a]
length :: Members [Error AppError, ReadStore] r => HasCodec a => List a -> Sem r Word64
elemIndex :: Members [Error AppError, ReadStore] r => HasCodec a => Eq a => a -> List a -> Sem r (Maybe Word64)
(!!) :: Members [Error AppError, ReadStore] r => HasCodec a => List a -> Word64 -> Sem r (Maybe a)
infixl 9 !!
instance GHC.Num.Num Tendermint.SDK.BaseApp.Store.List.Idx
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Store.List.Idx
instance GHC.Show.Show Tendermint.SDK.BaseApp.Store.List.Idx
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Store.List.Idx
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Tendermint.SDK.BaseApp.Store.List.HeadKey
instance Tendermint.SDK.BaseApp.Store.RawStore.IsKey Tendermint.SDK.BaseApp.Store.List.HeadKey (Tendermint.SDK.BaseApp.Store.List.List a)
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Tendermint.SDK.BaseApp.Store.List.ValueKey
instance Tendermint.SDK.BaseApp.Store.RawStore.IsKey Tendermint.SDK.BaseApp.Store.List.ValueKey (Tendermint.SDK.BaseApp.Store.List.List a)
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Tendermint.SDK.BaseApp.Store.List.IdxKey
instance Tendermint.SDK.BaseApp.Store.RawStore.IsKey Tendermint.SDK.BaseApp.Store.List.IdxKey (Tendermint.SDK.BaseApp.Store.List.List a)
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Tendermint.SDK.BaseApp.Store.List.Idx
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.BaseApp.Store.List.Idx
instance Tendermint.SDK.BaseApp.Store.RawStore.IsKey Tendermint.SDK.BaseApp.Store.List.Idx (Tendermint.SDK.BaseApp.Store.List.List a)

module Tendermint.SDK.BaseApp.Store.IAVLStore
data IAVLVersions
IAVLVersions :: IORef Version -> IORef Version -> IAVLVersions
[latest] :: IAVLVersions -> IORef Version
[committed] :: IAVLVersions -> IORef Version
initIAVLVersions :: IO IAVLVersions
evalStoreEffs :: Members [Embed IO, Reader IAVLVersions, Error AppError, Reader GrpcClient] r => forall a. Sem (StoreEffs :& r) a -> Sem r a
data GrpcClient

-- | initGrpcClient
data GrpcConfig
GrpcConfig :: String -> Integer -> GrpcConfig
[grpcHost] :: GrpcConfig -> String
[grpcPort] :: GrpcConfig -> Integer

-- | Initialize the GRPC Client
initGrpcClient :: GrpcConfig -> IO GrpcClient

module Tendermint.SDK.BaseApp.Effects.CoreEffs

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type CoreEffs = '[Reader LogConfig, Reader (Maybe PrometheusEnv), Reader IAVLVersions, Reader GrpcClient, Embed IO]

-- | <a>Context</a> is the environment required to run <a>CoreEffs</a> to
--   <a>IO</a>
data Context
Context :: LogConfig -> Maybe PrometheusEnv -> GrpcClient -> IAVLVersions -> Context
[_contextLogConfig] :: Context -> LogConfig
[_contextPrometheusEnv] :: Context -> Maybe PrometheusEnv
[_contextGrpcClient] :: Context -> GrpcClient
[_contextVersions] :: Context -> IAVLVersions
contextLogConfig :: Lens' Context LogConfig
contextPrometheusEnv :: Lens' Context (Maybe PrometheusEnv)
contextVersions :: Lens' Context IAVLVersions
contextGrpcClient :: Lens' Context GrpcClient
makeContext :: InitialLogNamespace -> Maybe MetricsScrapingConfig -> IAVLVersions -> GrpcConfig -> IO Context

-- | The standard interpeter for <a>CoreEffs</a>.
runCoreEffs :: Context -> forall a. Sem CoreEffs a -> IO a

module Tendermint.SDK.BaseApp.Store.Array

-- | A 'Array a' is an appendable list whose elements can be accessed | by
--   their index. You can also delete from the list, in which case
--   accessing | that index will result in a <a>Nothing</a>.
data Array (a :: Type)

-- | Smart constuctor to make sure we're making a <a>Array</a> from | the
--   appropriate key type.
makeArray :: IsKey k ns => Value k ns ~ Array a => k -> Store ns -> Value k ns
makeFullStoreKey :: Array a -> Word64 -> StoreKey

-- | Add an item to the end of the list.
append :: Members [Error AppError, ReadStore, WriteStore] r => HasCodec a => a -> Array a -> Sem r ()

-- | Modify a list at a particular index, return the | updated value if the
--   element was found.
modifyAtIndex :: Members [Error AppError, ReadStore, WriteStore] r => HasCodec a => Word64 -> (a -> a) -> Array a -> Sem r (Maybe a)

-- | Delete when the predicate evaluates to true.
deleteWhen :: Members [Error AppError, ReadStore, WriteStore] r => HasCodec a => (a -> Bool) -> Array a -> Sem r ()

-- | Access an item directly by its index.
(!!) :: Members [Error AppError, ReadStore] r => HasCodec a => Array a -> Word64 -> Sem r (Maybe a)
infixl 9 !!

-- | Get the first index where an element appears in the list.
elemIndex :: Members [Error AppError, ReadStore] r => HasCodec a => Eq a => a -> Array a -> Sem r (Maybe Word64)

-- | View the <a>Array</a> as a <a>Array</a>.
toList :: Members [Error AppError, ReadStore] r => HasCodec a => Array a -> Sem r [a]
instance GHC.Num.Num Tendermint.SDK.BaseApp.Store.Array.Idx
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Store.Array.Idx
instance GHC.Show.Show Tendermint.SDK.BaseApp.Store.Array.Idx
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Store.Array.Idx
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Tendermint.SDK.BaseApp.Store.Array.LengthKey
instance Tendermint.SDK.BaseApp.Store.RawStore.IsKey Tendermint.SDK.BaseApp.Store.Array.LengthKey (Tendermint.SDK.BaseApp.Store.Array.Array a)
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Tendermint.SDK.BaseApp.Store.Array.Idx
instance Tendermint.SDK.BaseApp.Store.RawStore.IsKey Tendermint.SDK.BaseApp.Store.Array.Idx (Tendermint.SDK.BaseApp.Store.Array.Array a)

module Tendermint.SDK.BaseApp.Store.TH
makeSubStore :: Name -> String -> TypeQ -> ByteString -> Q [Dec]
class RawKey k => IsKey k ns where {
    type family Value k ns :: Type;
}
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString

-- | Keys
class RawKey k
rawKey :: RawKey k => Iso' k ByteString
data Var (a :: Type)
makeVar :: IsKey k ns => Value k ns ~ Var a => k -> Store ns -> Value k ns

-- | A 'Array a' is an appendable list whose elements can be accessed | by
--   their index. You can also delete from the list, in which case
--   accessing | that index will result in a <a>Nothing</a>.
data Array (a :: Type)

-- | Smart constuctor to make sure we're making a <a>Array</a> from | the
--   appropriate key type.
makeArray :: IsKey k ns => Value k ns ~ Array a => k -> Store ns -> Value k ns
data List (a :: Type)
makeList :: IsKey key ns => Value key ns ~ List a => key -> Store ns -> Value key ns
data Map (k :: Type) (v :: Type)
makeMap :: IsKey key ns => Value key ns ~ Map k v => key -> Store ns -> Value key ns

module Tendermint.SDK.BaseApp.Router.Types
type Application m req res = req -> m (RouteResult res)
data RouterError
PathNotFound :: RouterError
ResourceNotFound :: RouterError
InvalidRequest :: Text -> RouterError
InternalError :: Text -> RouterError
data RouteResult a
Fail :: RouterError -> RouteResult a
FailFatal :: RouterError -> RouteResult a
Route :: a -> RouteResult a
data RouteResultT m a
RouteResultT :: m (RouteResult a) -> RouteResultT m a
[runRouteResultT] :: RouteResultT m a -> m (RouteResult a)
class HasPath t
path :: HasPath t => Lens' t Text
instance GHC.Base.Functor m => GHC.Base.Functor (Tendermint.SDK.BaseApp.Router.Types.RouteResultT m)
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Router.Types.RouteResult
instance GHC.Show.Show Tendermint.SDK.BaseApp.Router.Types.RouterError
instance Control.Monad.Trans.Class.MonadTrans Tendermint.SDK.BaseApp.Router.Types.RouteResultT
instance GHC.Base.Monad m => GHC.Base.Applicative (Tendermint.SDK.BaseApp.Router.Types.RouteResultT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Tendermint.SDK.BaseApp.Router.Types.RouteResultT m)
instance GHC.Base.Applicative Tendermint.SDK.BaseApp.Router.Types.RouteResult
instance GHC.Base.Monad Tendermint.SDK.BaseApp.Router.Types.RouteResult
instance Tendermint.SDK.BaseApp.Errors.IsAppError Tendermint.SDK.BaseApp.Router.Types.RouterError

module Tendermint.SDK.BaseApp.Router.Router
type Router env r req res = Router' env (Application (Sem r) req res)
data Router' env a
StaticRouter :: Map Text (Router' env a) -> [env -> a] -> Router' env a
CaptureRouter :: Router' (Text, env) a -> Router' env a
Choice :: Router' env a -> Router' env a -> Router' env a
runRouter :: HasPath req => Router env r req res -> env -> Application (Sem r) req res
pathRouter :: Text -> Router' env a -> Router' env a
leafRouter :: (env -> a) -> Router' env a
choice :: Router' env a -> Router' env a -> Router' env a

module Tendermint.SDK.BaseApp.Router.Delayed
data Delayed m env req a
runAction :: Delayed (Sem r) env req (Sem r a) -> env -> req -> (a -> Sem r (RouteResult b)) -> Sem r (RouteResult b)

-- | Fail with the option to recover.
delayedFail :: Monad m => RouterError -> DelayedM m req a
addBody :: Monad m => Delayed m env req (a -> b) -> DelayedM m req a -> Delayed m env req b
addCapture :: Monad m => Delayed m env req (a -> b) -> (captured -> DelayedM m req a) -> Delayed m (captured, env) req b
addParameter :: Monad m => Delayed m env req (a -> b) -> DelayedM m req a -> Delayed m env req b
emptyDelayed :: Monad m => RouteResult a -> Delayed m b req a

-- | Gain access to the incoming request.
withRequest :: Monad m => (req -> DelayedM m req a) -> DelayedM m req a
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader req (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Monad m => GHC.Base.Monad (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Monad m => GHC.Base.Applicative (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Functor m => GHC.Base.Functor (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Functor m => GHC.Base.Functor (Tendermint.SDK.BaseApp.Router.Delayed.Delayed m env req)

module Tendermint.SDK.BaseApp.Query.Types
data Leaf (a :: Type)
data QA (a :: Type)
data EmptyQueryServer
EmptyQueryServer :: EmptyQueryServer

-- | This class is used to parse the 'data' field of the query request
--   message. | The default method assumes that the 'data' is simply the
--   key for the | value being queried.
class QueryData a
fromQueryData :: QueryData a => Base64String -> Either String a
toQueryData :: QueryData a => a -> Base64String
fromQueryData :: (QueryData a, RawKey a) => Base64String -> Either String a
toQueryData :: (QueryData a, RawKey a) => a -> Base64String
type QueryApplication m = Query -> m Query
data QueryRequest
QueryRequest :: Text -> Text -> Base64String -> Bool -> Int64 -> QueryRequest
[queryRequestPath] :: QueryRequest -> Text
[queryRequestParamString] :: QueryRequest -> Text
[queryRequestData] :: QueryRequest -> Base64String
[queryRequestProve] :: QueryRequest -> Bool
[queryRequestHeight] :: QueryRequest -> Int64
parseQueryRequest :: Query -> QueryRequest
data QueryArgs a
QueryArgs :: Bool -> a -> Int64 -> QueryArgs a
[queryArgsProve] :: QueryArgs a -> Bool
[queryArgsData] :: QueryArgs a -> a
[queryArgsHeight] :: QueryArgs a -> Int64
defaultQueryArgs :: QueryArgs ()
data QueryResult a
QueryResult :: a -> Int64 -> Base64String -> Maybe Proof -> Int64 -> QueryResult a
[queryResultData] :: QueryResult a -> a
[queryResultIndex] :: QueryResult a -> Int64
[queryResultKey] :: QueryResult a -> Base64String
[queryResultProof] :: QueryResult a -> Maybe Proof
[queryResultHeight] :: QueryResult a -> Int64
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Query.Types.QueryResult
instance GHC.Show.Show a => GHC.Show.Show (Tendermint.SDK.BaseApp.Query.Types.QueryResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Tendermint.SDK.BaseApp.Query.Types.QueryResult a)
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Query.Types.QueryArgs
instance GHC.Show.Show Tendermint.SDK.BaseApp.Query.Types.QueryRequest
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Query.Types.QueryRequest
instance Tendermint.SDK.BaseApp.Query.Types.QueryData Tendermint.SDK.Types.Address.Address
instance Tendermint.SDK.BaseApp.Query.Types.QueryData Data.Text.Internal.Text
instance Tendermint.SDK.BaseApp.Query.Types.QueryData GHC.Word.Word64
instance Tendermint.SDK.BaseApp.Query.Types.QueryData ()
instance Tendermint.SDK.BaseApp.Router.Types.HasPath Tendermint.SDK.BaseApp.Query.Types.QueryRequest

module Tendermint.SDK.BaseApp.Query.Router

-- | This class is used to construct a router given a <tt>layout</tt> type.
--   The layout | is constructed using the combinators that appear in the
--   instances here, no other | Servant combinators are recognized.
class HasQueryRouter layout r where {
    
    -- | A routeQ handler.
    type family RouteQ layout r :: Type;
}

-- | Transform a routeQ handler into a <tt>Router</tt>.
routeQ :: HasQueryRouter layout r => Proxy layout -> Proxy r -> Delayed (Sem r) env QueryRequest (RouteQ layout (QueryEffs :& r)) -> Router env r QueryRequest Query
hoistQueryRouter :: HasQueryRouter layout r => Proxy layout -> Proxy r -> (forall a. Sem s a -> Sem s' a) -> RouteQ layout s -> RouteQ layout s'
methodRouter :: HasCodec a => Member (Tagged 'QueryAndMempool ReadStore) r => Delayed (Sem r) env req (Sem (QueryEffs :& r) (QueryResult a)) -> Router env r req Query
instance (Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter a r, Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter b r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (a Servant.API.Alternative.:<|> b) r
instance (Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r, GHC.TypeLits.KnownSymbol path) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (path Servant.API.Sub.:> sublayout) r
instance (Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r, GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods), Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldLenient mods)) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> sublayout) r
instance (Web.Internal.HttpApiData.FromHttpApiData a, Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Servant.API.Capture.Capture' mods capture a Servant.API.Sub.:> sublayout) r
instance (Tendermint.SDK.BaseApp.Query.Types.QueryData a, Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Types.QA a Servant.API.Sub.:> sublayout) r
instance (Polysemy.Internal.Union.Member (Polysemy.Tagged.Tagged 'Tendermint.SDK.BaseApp.Store.RawStore.QueryAndMempool Tendermint.SDK.BaseApp.Store.RawStore.ReadStore) r, Tendermint.SDK.Codec.HasCodec a) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Types.Leaf a) r
instance Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter Tendermint.SDK.BaseApp.Query.Types.EmptyQueryServer r

module Tendermint.SDK.BaseApp.Query.Store
data StoreLeaf a
storeQueryHandler :: StoreQueryHandler ns h => ns -> h
instance (Tendermint.SDK.BaseApp.Store.RawStore.RawKey k, Tendermint.SDK.Codec.HasCodec v, Polysemy.Internal.Members Tendermint.SDK.BaseApp.Query.Effect.QueryEffs r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandler (Tendermint.SDK.BaseApp.Store.Map.Map k v) (Tendermint.SDK.BaseApp.Query.Types.QueryArgs k -> Polysemy.Internal.Sem r (Tendermint.SDK.BaseApp.Query.Types.QueryResult v))
instance (Tendermint.SDK.Codec.HasCodec a, Polysemy.Internal.Members Tendermint.SDK.BaseApp.Query.Effect.QueryEffs r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandler (Tendermint.SDK.BaseApp.Store.Array.Array a) (Tendermint.SDK.BaseApp.Query.Types.QueryArgs GHC.Word.Word64 -> Polysemy.Internal.Sem r (Tendermint.SDK.BaseApp.Query.Types.QueryResult a))
instance (Tendermint.SDK.Codec.HasCodec a, Polysemy.Internal.Members Tendermint.SDK.BaseApp.Query.Effect.QueryEffs r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandler (Tendermint.SDK.BaseApp.Store.List.List a) (Tendermint.SDK.BaseApp.Query.Types.QueryArgs GHC.Word.Word64 -> Polysemy.Internal.Sem r (Tendermint.SDK.BaseApp.Query.Types.QueryResult a))
instance (Tendermint.SDK.Codec.HasCodec a, Polysemy.Internal.Members Tendermint.SDK.BaseApp.Query.Effect.QueryEffs r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandler (Tendermint.SDK.BaseApp.Store.Var.Var a) (Tendermint.SDK.BaseApp.Query.Types.QueryArgs () -> Polysemy.Internal.Sem r (Tendermint.SDK.BaseApp.Query.Types.QueryResult a))
instance (Tendermint.SDK.BaseApp.Query.Types.QueryData k, Tendermint.SDK.Codec.HasCodec v, Polysemy.Internal.Union.Member (Polysemy.Tagged.Tagged 'Tendermint.SDK.BaseApp.Store.RawStore.QueryAndMempool Tendermint.SDK.BaseApp.Store.RawStore.ReadStore) r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Store.StoreLeaf (Tendermint.SDK.BaseApp.Store.Map.Map k v)) r
instance (Tendermint.SDK.Codec.HasCodec a, Polysemy.Internal.Union.Member (Polysemy.Tagged.Tagged 'Tendermint.SDK.BaseApp.Store.RawStore.QueryAndMempool Tendermint.SDK.BaseApp.Store.RawStore.ReadStore) r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Store.StoreLeaf (Tendermint.SDK.BaseApp.Store.Var.Var a)) r
instance (Tendermint.SDK.Codec.HasCodec a, Polysemy.Internal.Union.Member (Polysemy.Tagged.Tagged 'Tendermint.SDK.BaseApp.Store.RawStore.QueryAndMempool Tendermint.SDK.BaseApp.Store.RawStore.ReadStore) r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Store.StoreLeaf (Tendermint.SDK.BaseApp.Store.Array.Array a)) r

module Tendermint.SDK.BaseApp.Query
serveQueryApplication :: HasQueryRouter layout r => Proxy layout -> Proxy r -> RouteQ layout (QueryEffs :& r) -> QueryApplication (Sem r)

-- | This class is used to construct a router given a <tt>layout</tt> type.
--   The layout | is constructed using the combinators that appear in the
--   instances here, no other | Servant combinators are recognized.
class HasQueryRouter layout r where {
    
    -- | A routeQ handler.
    type family RouteQ layout r :: Type;
}

-- | Transform a routeQ handler into a <tt>Router</tt>.
routeQ :: HasQueryRouter layout r => Proxy layout -> Proxy r -> Delayed (Sem r) env QueryRequest (RouteQ layout (QueryEffs :& r)) -> Router env r QueryRequest Query
hoistQueryRouter :: HasQueryRouter layout r => Proxy layout -> Proxy r -> (forall a. Sem s a -> Sem s' a) -> RouteQ layout s -> RouteQ layout s'
data StoreLeaf a
storeQueryHandler :: StoreQueryHandler ns h => ns -> h
type QueryEffs = '[ReadStore, Error AppError]

module Tendermint.SDK.BaseApp.Gas
data GasMeter m a
[WithGas] :: forall m a. GasAmount -> m a -> GasMeter m a
newtype GasAmount
GasAmount :: Int64 -> GasAmount
[unGasAmount] :: GasAmount -> Int64
withGas :: forall r_a1N41 a_a1MU8. MemberWithError GasMeter r_a1N41 => GasAmount -> Sem r_a1N41 a_a1MU8 -> Sem r_a1N41 a_a1MU8
eval :: Members [Error AppError, State GasAmount] r => Sem (GasMeter : r) a -> Sem r a
doNothing :: forall r. forall a. Sem (GasMeter : r) a -> Sem r a
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Gas.GasAmount
instance GHC.Num.Num Tendermint.SDK.BaseApp.Gas.GasAmount
instance GHC.Show.Show Tendermint.SDK.BaseApp.Gas.GasAmount
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Gas.GasAmount

module Tendermint.SDK.BaseApp.Transaction.Types
type TransactionApplication m = RoutingTx ByteString -> m (TxResult, Maybe Cache)
data TransactionContext
TransactionContext :: IORef GasAmount -> Bool -> IORef Cache -> IORef [Event] -> TransactionContext
[gasRemaining] :: TransactionContext -> IORef GasAmount
[txRequiresGas] :: TransactionContext -> Bool
[storeCache] :: TransactionContext -> IORef Cache
[events] :: TransactionContext -> IORef [Event]
data RoutingTx msg
[RoutingTx] :: Tx alg msg -> RoutingTx msg
data RouteContext
CheckTx :: RouteContext
DeliverTx :: RouteContext
data EmptyTxServer
EmptyTxServer :: EmptyTxServer
data Return a
data TypedMessage msg
data msg :~> a
newTransactionContext :: Bool -> RoutingTx msg -> IO TransactionContext
data Tx alg msg
Tx :: Msg msg -> Text -> Int64 -> RecoverableSignature alg -> Message alg -> PubKey alg -> Word64 -> Tx alg msg
[txMsg] :: Tx alg msg -> Msg msg
[txRoute] :: Tx alg msg -> Text
[txGas] :: Tx alg msg -> Int64
[txSignature] :: Tx alg msg -> RecoverableSignature alg
[txSignBytes] :: Tx alg msg -> Message alg
[txSigner] :: Tx alg msg -> PubKey alg
[txNonce] :: Tx alg msg -> Word64
instance GHC.Show.Show Tendermint.SDK.BaseApp.Transaction.Types.RouteContext
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Transaction.Types.RouteContext
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Transaction.Types.RoutingTx
instance Tendermint.SDK.BaseApp.Router.Types.HasPath (Tendermint.SDK.BaseApp.Transaction.Types.RoutingTx msg)

module Tendermint.SDK.BaseApp.Transaction.Checker
class DefaultCheckTx api (r :: EffectRow) where {
    type family DefaultCheckTxT api r :: Type;
}
defaultCheckTx :: DefaultCheckTx api r => Proxy api -> Proxy r -> DefaultCheckTxT api r
type family VoidReturn (api :: Type) :: Type
instance (Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx a r, Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx b r) => Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx (a Servant.API.Alternative.:<|> b) r
instance forall k rest (r :: Polysemy.Internal.Kind.EffectRow) (path :: k). Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx rest r => Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx (path Servant.API.Sub.:> rest) r
instance forall k (r :: [(* -> *) -> * -> *]) msg (a :: k). (Polysemy.Internal.Union.Member (Polysemy.Error.Error Tendermint.SDK.BaseApp.Errors.AppError) r, Tendermint.SDK.Types.Message.ValidateMessage msg) => Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx (Tendermint.SDK.BaseApp.Transaction.Types.TypedMessage msg Tendermint.SDK.BaseApp.Transaction.Types.:~> Tendermint.SDK.BaseApp.Transaction.Types.Return a) r
instance Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx Tendermint.SDK.BaseApp.Transaction.Types.EmptyTxServer r

module Tendermint.SDK.BaseApp.Transaction.AnteHandler
type AnteHandler r = forall msg a. (Endo (RoutingTx msg -> Sem r a))

module Tendermint.SDK.BaseApp.Transaction.Effect
type TxEffs = [Output Event, GasMeter, WriteStore, ReadStore, Error AppError]
runTx :: Members [Embed IO, Tagged scope ReadStore] r => HasCodec a => Proxy scope -> TransactionContext -> Sem (TxEffs :& r) a -> Sem r (Maybe (a, Cache), TxResult)
eval :: forall r scope a. Members [Embed IO, Tagged scope ReadStore] r => Proxy scope -> TransactionContext -> Sem (TxEffs :& r) a -> Sem r (Either AppError a)
evalReadOnly :: forall r. forall a. Sem (TxEffs :& r) a -> Sem (ReadStore : (Error AppError : r)) a

module Tendermint.SDK.BaseApp.Transaction.Router
class HasTxRouter layout (r :: EffectRow) (scope :: Scope) where {
    type family RouteTx layout (s :: EffectRow) :: Type;
}
routeTx :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> Delayed (Sem r) env (RoutingTx ByteString) (RouteTx layout (TxEffs :& r)) -> Router env r (RoutingTx ByteString) (TxResult, Maybe Cache)
applyAnteHandler :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> AnteHandler r -> RouteTx layout r -> RouteTx layout r
hoistTxRouter :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> (forall a. Sem s a -> Sem s' a) -> RouteTx layout s -> RouteTx layout s'
emptyTxServer :: RouteTx EmptyTxServer r
instance (Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter a r scope, Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter b r scope) => Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter (a Servant.API.Alternative.:<|> b) r scope
instance (Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter sublayout r scope, GHC.TypeLits.KnownSymbol path) => Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter (path Servant.API.Sub.:> sublayout) r scope
instance (Tendermint.SDK.Types.Message.HasMessageType msg, Tendermint.SDK.Codec.HasCodec msg, Polysemy.Internal.Members '[Polysemy.Tagged.Tagged scope Tendermint.SDK.BaseApp.Store.RawStore.ReadStore, Polysemy.Embed.Type.Embed GHC.Types.IO] r, Tendermint.SDK.Codec.HasCodec a) => Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter (Tendermint.SDK.BaseApp.Transaction.Types.TypedMessage msg Tendermint.SDK.BaseApp.Transaction.Types.:~> Tendermint.SDK.BaseApp.Transaction.Types.Return a) r scope
instance Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter Tendermint.SDK.BaseApp.Transaction.Types.EmptyTxServer r scope

module Tendermint.SDK.BaseApp.Transaction
serveTxApplication :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> RouteTx layout (TxEffs :& r) -> TransactionApplication (Sem r)
class HasTxRouter layout (r :: EffectRow) (scope :: Scope) where {
    type family RouteTx layout (s :: EffectRow) :: Type;
}
routeTx :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> Delayed (Sem r) env (RoutingTx ByteString) (RouteTx layout (TxEffs :& r)) -> Router env r (RoutingTx ByteString) (TxResult, Maybe Cache)
applyAnteHandler :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> AnteHandler r -> RouteTx layout r -> RouteTx layout r
hoistTxRouter :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> (forall a. Sem s a -> Sem s' a) -> RouteTx layout s -> RouteTx layout s'
emptyTxServer :: RouteTx EmptyTxServer r
class DefaultCheckTx api (r :: EffectRow) where {
    type family DefaultCheckTxT api r :: Type;
}
defaultCheckTx :: DefaultCheckTx api r => Proxy api -> Proxy r -> DefaultCheckTxT api r
type family VoidReturn (api :: Type) :: Type
type TxEffs = [Output Event, GasMeter, WriteStore, ReadStore, Error AppError]
evalReadOnly :: forall r. forall a. Sem (TxEffs :& r) a -> Sem (ReadStore : (Error AppError : r)) a
type AnteHandler r = forall msg a. (Endo (RoutingTx msg -> Sem r a))

module Tendermint.SDK.BaseApp.Effects.PureCoreEffs

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type PureCoreEffs = '[Reader LogConfig, Reader DBVersions, Reader DB, Error AppError, Embed IO]

-- | <tt>Context</tt> is the environment required to run
--   <tt>CoreEffsPure</tt> to <a>IO</a>
data PureContext
PureContext :: LogConfig -> DB -> DBVersions -> PureContext
[_pureContextLogConfig] :: PureContext -> LogConfig
[_pureContextDB] :: PureContext -> DB
[_pureContextVersions] :: PureContext -> DBVersions
pureContextLogConfig :: Lens' PureContext LogConfig
pureContextVersions :: Lens' PureContext DBVersions
pureContextDB :: Lens' PureContext DB
makePureContext :: InitialLogNamespace -> IO PureContext

-- | The standard interpeter for <a>PureCoreEffs</a>.
runPureCoreEffs :: PureContext -> forall a. Sem PureCoreEffs a -> IO (Either AppError a)

module Tendermint.SDK.BaseApp.Effects.BaseEffs

-- | Concrete row of effects for the BaseApp. Note that because there does
--   | not exist an interpreter for an untagged <tt>RawStore</tt>, you must
--   scope | these effects before they can be interpreted.
type BaseEffs = [Metrics, Logger, Resource, Error AppError]

-- | An intermediary interpeter, bringing <tt>BaseApp</tt> down to
--   <tt>CoreEff</tt>.
evalBaseEffs :: Members [Embed IO, Reader LogConfig, Reader (Maybe PrometheusEnv)] core => forall a. Sem (BaseEffs :& core) a -> Sem core a
evalBaseEffsPure :: Members [Embed IO, Reader LogConfig] core => forall a. Sem (BaseEffs :& core) a -> Sem core a

module Tendermint.SDK.BaseApp.Effects
type BaseAppEffs core = StoreEffs :& BaseEffs :& core
defaultCompileToCore :: forall a. Sem (BaseAppEffs CoreEffs) a -> Sem CoreEffs a
defaultCompileToPureCore :: forall a. Sem (BaseAppEffs PureCoreEffs) a -> Sem PureCoreEffs a

module Tendermint.SDK.Application.App
createIOApp :: forall r. (forall a. Sem r a -> IO a) -> App (Sem r) -> App IO

module Tendermint.SDK.BaseApp

-- | Concrete row of effects for the BaseApp. Note that because there does
--   | not exist an interpreter for an untagged <tt>RawStore</tt>, you must
--   scope | these effects before they can be interpreted.
type BaseEffs = [Metrics, Logger, Resource, Error AppError]
defaultCompileToCore :: forall a. Sem (BaseAppEffs CoreEffs) a -> Sem CoreEffs a
defaultCompileToPureCore :: forall a. Sem (BaseAppEffs PureCoreEffs) a -> Sem PureCoreEffs a
type BaseAppEffs core = StoreEffs :& BaseEffs :& core

-- | This type family gives a nice syntax for combining multiple lists of
--   effects.
type family (as :: [a]) :& (bs :: [a]) :: [a]
infixr 5 :&

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type CoreEffs = '[Reader LogConfig, Reader (Maybe PrometheusEnv), Reader IAVLVersions, Reader GrpcClient, Embed IO]

-- | <a>Context</a> is the environment required to run <a>CoreEffs</a> to
--   <a>IO</a>
data Context
Context :: LogConfig -> Maybe PrometheusEnv -> GrpcClient -> IAVLVersions -> Context
[_contextLogConfig] :: Context -> LogConfig
[_contextPrometheusEnv] :: Context -> Maybe PrometheusEnv
[_contextGrpcClient] :: Context -> GrpcClient
[_contextVersions] :: Context -> IAVLVersions
contextLogConfig :: Lens' Context LogConfig
contextPrometheusEnv :: Lens' Context (Maybe PrometheusEnv)
contextVersions :: Lens' Context IAVLVersions
makeContext :: InitialLogNamespace -> Maybe MetricsScrapingConfig -> IAVLVersions -> GrpcConfig -> IO Context

-- | The standard interpeter for <a>CoreEffs</a>.
runCoreEffs :: Context -> forall a. Sem CoreEffs a -> IO a

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type PureCoreEffs = '[Reader LogConfig, Reader DBVersions, Reader DB, Error AppError, Embed IO]

-- | <tt>Context</tt> is the environment required to run
--   <tt>CoreEffsPure</tt> to <a>IO</a>
data PureContext
PureContext :: LogConfig -> DB -> DBVersions -> PureContext
[_pureContextLogConfig] :: PureContext -> LogConfig
[_pureContextDB] :: PureContext -> DB
[_pureContextVersions] :: PureContext -> DBVersions
pureContextLogConfig :: Lens' PureContext LogConfig
pureContextVersions :: Lens' PureContext DBVersions
pureContextDB :: Lens' PureContext DB
makePureContext :: InitialLogNamespace -> IO PureContext

-- | The standard interpeter for <a>PureCoreEffs</a>.
runPureCoreEffs :: PureContext -> forall a. Sem PureCoreEffs a -> IO (Either AppError a)

-- | Read and Write Effects
data ReadStore m a
data WriteStore m a

-- | Keys
class RawKey k
rawKey :: RawKey k => Iso' k ByteString
data StoreKey
StoreKey :: [ByteString] -> ByteString -> StoreKey
[skPathFromRoot] :: StoreKey -> [ByteString]
[skKey] :: StoreKey -> ByteString
class RawKey k => IsKey k ns where {
    type family Value k ns :: Type;
}
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
data Store ns

-- | Store
newtype KeyRoot ns
KeyRoot :: ByteString -> KeyRoot ns
makeStore :: KeyRoot ns -> Store ns
put :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Member WriteStore r => Store ns -> k -> Value k ns -> Sem r ()
get :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Members [ReadStore, Error AppError] r => Store ns -> k -> Sem r (Maybe (Value k ns))
delete :: forall k ns r. IsKey k ns => Member WriteStore r => Store ns -> k -> Sem r ()
data Leaf (a :: Type)
data QA (a :: Type)
data StoreLeaf a

-- | This type represents a common error response for the query, checkTx, |
--   and deliver tx abci-messages.
data AppError
AppError :: Word32 -> Text -> Text -> AppError
[appErrorCode] :: AppError -> Word32
[appErrorCodespace] :: AppError -> Text
[appErrorMessage] :: AppError -> Text

-- | Allows for custom application error types to be coerced into the
--   standard error resposne.
class IsAppError e
makeAppError :: IsAppError e => e -> AppError
data Event
Event :: Text -> [KVPair] -> Event

-- | Type of Event
[eventType] :: Event -> Text

-- | Event attributes
[eventAttributes] :: Event -> [KVPair]

-- | A class representing a type that can be emitted as an event in the |
--   event logs for the deliverTx response.
class ToEvent e
toEvent :: ToEvent e => e -> Event
toEvent :: (ToEvent e, Generic e, GToEvent (Rep e)) => e -> Event

-- | Special event wrapper to add contextual event_type info
newtype ContextEvent t
ContextEvent :: t -> ContextEvent t
emit :: ToEvent e => Member (Output Event) r => e -> Sem r ()
logEvent :: forall e r. (ToJSON e, ToEvent e, Select e) => Member Logger r => e -> Sem r ()
data GasMeter m a
withGas :: forall r_a1N41 a_a1MU8. MemberWithError GasMeter r_a1N41 => GasAmount -> Sem r_a1N41 a_a1MU8 -> Sem r_a1N41 a_a1MU8

-- | Effect allowing for console logging.
data Logger m a
log :: forall r_aEAt. MemberWithError Logger r_aEAt => Severity -> Text -> Sem r_aEAt ()
data LogSelect
All :: LogSelect
Some :: [Text] -> LogSelect
addContext :: forall r_aEAw x_XDgm a_aDgn. (MemberWithError Logger r_aEAw, Select x_XDgm, ToJSON x_XDgm) => x_XDgm -> Sem r_aEAw a_aDgn -> Sem r_aEAw a_aDgn
data Severity
Debug :: Severity
Info :: Severity
Warning :: Severity
Error :: Severity
Exception :: Severity

-- | Class for selecting object keys for contextual logging
class Select a
select :: Select a => Verbosity -> a -> LogSelect
select :: Select a => Verbosity -> a -> LogSelect
data Verbosity
V0 :: Verbosity
V1 :: Verbosity
V2 :: Verbosity
V3 :: Verbosity
data Metrics m a
incCount :: forall r_aNv5. MemberWithError Metrics r_aNv5 => CountName -> Sem r_aNv5 ()
withTimer :: forall r_aNv7 a_aNng. MemberWithError Metrics r_aNv7 => HistogramName -> Sem r_aNv7 a_aNng -> Sem r_aNv7 a_aNng
data CountName
CountName :: Text -> [(Text, Text)] -> CountName
[countName] :: CountName -> Text
[countLabels] :: CountName -> [(Text, Text)]
data HistogramName
HistogramName :: Text -> [(Text, Text)] -> [Double] -> HistogramName
[histogramName] :: HistogramName -> Text
[histogramLabels] :: HistogramName -> [(Text, Text)]
[histogramBuckets] :: HistogramName -> [Double]
type AnteHandler r = forall msg a. (Endo (RoutingTx msg -> Sem r a))
data RoutingTx msg
[RoutingTx] :: Tx alg msg -> RoutingTx msg
type family RouteTx layout (s :: EffectRow) :: Type
data RouteContext
CheckTx :: RouteContext
DeliverTx :: RouteContext
data Return a
data msg :~> a
data TypedMessage msg
type TxEffs = [Output Event, GasMeter, WriteStore, ReadStore, Error AppError]
data EmptyTxServer
EmptyTxServer :: EmptyTxServer
class DefaultCheckTx api (r :: EffectRow) where {
    type family DefaultCheckTxT api r :: Type;
}
defaultCheckTx :: DefaultCheckTx api r => Proxy api -> Proxy r -> DefaultCheckTxT api r
type family VoidReturn (api :: Type) :: Type
type QueryEffs = '[ReadStore, Error AppError]

-- | This class is used to parse the 'data' field of the query request
--   message. | The default method assumes that the 'data' is simply the
--   key for the | value being queried.
class QueryData a
fromQueryData :: QueryData a => Base64String -> Either String a
toQueryData :: QueryData a => a -> Base64String
fromQueryData :: (QueryData a, RawKey a) => Base64String -> Either String a
toQueryData :: (QueryData a, RawKey a) => a -> Base64String

-- | A routeQ handler.
type family RouteQ layout r :: Type
data QueryResult a
QueryResult :: a -> Int64 -> Base64String -> Maybe Proof -> Int64 -> QueryResult a
[queryResultData] :: QueryResult a -> a
[queryResultIndex] :: QueryResult a -> Int64
[queryResultKey] :: QueryResult a -> Base64String
[queryResultProof] :: QueryResult a -> Maybe Proof
[queryResultHeight] :: QueryResult a -> Int64
storeQueryHandler :: StoreQueryHandler ns h => ns -> h
data EmptyQueryServer
EmptyQueryServer :: EmptyQueryServer
data RouterError
ResourceNotFound :: RouterError
type BlockEffs = TxEffs
data EndBlockResult
EndBlockResult :: [ValidatorUpdate] -> Maybe ConsensusParams -> EndBlockResult
defaultBeginBlocker :: BeginBlock -> Sem r ()
defaultEndBlocker :: EndBlock -> Sem r EndBlockResult

module Tendermint.SDK.Application.Module
data Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow)
Module :: RouteTx check r -> RouteTx deliver r -> RouteQ query r -> (forall s. (Members TxEffs s, Members BaseEffs s, Members (DependencyEffs deps) s) => forall a. Sem (es :& s) a -> Sem s a) -> Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow)
[moduleTxChecker] :: Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow) -> RouteTx check r
[moduleTxDeliverer] :: Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow) -> RouteTx deliver r
[moduleQuerier] :: Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow) -> RouteQ query r
[moduleEval] :: Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow) -> forall s. (Members TxEffs s, Members BaseEffs s, Members (DependencyEffs deps) s) => forall a. Sem (es :& s) a -> Sem s a
type Component = EffectRow -> Type
type family ModuleEffs (m :: Component) :: EffectRow
data ModuleList (ms :: [Component]) r
[NilModules] :: ModuleList '[] r
[:+] :: Module name check deliver query es deps r -> ModuleList ms r -> ModuleList (Module name check deliver query es deps : ms) r
infixr 5 :+
data Application check deliver query r s
Application :: RouteTx check r -> RouteTx deliver r -> RouteQ query s -> (BeginBlock -> Sem r ()) -> (EndBlock -> Sem r EndBlockResult) -> Application check deliver query r s
[applicationTxChecker] :: Application check deliver query r s -> RouteTx check r
[applicationTxDeliverer] :: Application check deliver query r s -> RouteTx deliver r
[applicationQuerier] :: Application check deliver query r s -> RouteQ query s
[applicationBeginBlocker] :: Application check deliver query r s -> BeginBlock -> Sem r ()
[applicationEndBlocker] :: Application check deliver query r s -> EndBlock -> Sem r EndBlockResult
class ToApplication ms r where {
    type family ApplicationC ms :: Type;
    type family ApplicationD ms :: Type;
    type family ApplicationQ ms :: Type;
}
toApplication :: ToApplication ms r => ModuleList ms r -> Application (ApplicationC ms) (ApplicationD ms) (ApplicationQ ms) r r
hoistApplication :: HasTxRouter check r 'QueryAndMempool => HasTxRouter deliver r 'Consensus => HasQueryRouter query s => (forall a. Sem r a -> Sem r' a) -> (forall a. Sem s a -> Sem s' a) -> Application check deliver query r s -> Application check deliver query r' s'
class Eval ms (core :: EffectRow) where {
    type family Effs ms core :: EffectRow;
}
eval :: Eval ms core => proxy core -> ModuleList ms r -> forall a. Sem (Effs ms core) a -> Sem (TxEffs :& BaseAppEffs core) a
makeApplication :: Eval ms core => ToApplication ms (Effs ms core) => HasTxRouter (ApplicationC ms) (Effs ms core) 'QueryAndMempool => HasTxRouter (ApplicationD ms) (Effs ms core) 'Consensus => HasQueryRouter (ApplicationQ ms) (Effs ms core) => Proxy core -> AnteHandler (Effs ms core) -> ModuleList ms (Effs ms core) -> (BeginBlock -> Sem (Effs ms core) ()) -> (EndBlock -> Sem (Effs ms core) EndBlockResult) -> Application (ApplicationC ms) (ApplicationD ms) (ApplicationQ ms) (TxEffs :& BaseAppEffs core) (QueryEffs :& BaseAppEffs core)
applyAnteHandler :: HasTxRouter check r 'QueryAndMempool => HasTxRouter deliver r 'Consensus => AnteHandler r -> Application check deliver query r s -> Application check deliver query r s
instance (Tendermint.SDK.Application.Module.DependencyEffs deps GHC.Types.~ '[]) => Tendermint.SDK.Application.Module.Eval '[Tendermint.SDK.Application.Module.Module name check deliver query es deps] core
instance (Polysemy.Internal.Members (Tendermint.SDK.Application.Module.DependencyEffs deps) (Tendermint.SDK.Application.Module.Effs (m' : ms) s), Polysemy.Internal.Members Tendermint.SDK.BaseApp.Transaction.Effect.TxEffs (Tendermint.SDK.Application.Module.Effs (m' : ms) s), Polysemy.Internal.Members Tendermint.SDK.BaseApp.Effects.BaseEffs.BaseEffs (Tendermint.SDK.Application.Module.Effs (m' : ms) s), Tendermint.SDK.Application.Module.Eval (m' : ms) s) => Tendermint.SDK.Application.Module.Eval (Tendermint.SDK.Application.Module.Module name check deliver query es deps : m' : ms) s
instance Tendermint.SDK.Application.Module.ToApplication '[Tendermint.SDK.Application.Module.Module name check deliver query es deps] r
instance Tendermint.SDK.Application.Module.ToApplication (m' : ms) r => Tendermint.SDK.Application.Module.ToApplication (Tendermint.SDK.Application.Module.Module name check deliver query es deps : m' : ms) r

module Tendermint.SDK.Modules.Auth
type Auth = Module AuthName EmptyTxServer EmptyTxServer Api AuthEffs '[]
authModule :: Members (ModuleEffs Auth) r => Auth r
data Accounts m a
[CreateAccount] :: Address -> Accounts m Account
[UpdateAccount] :: Address -> (Account -> Account) -> Accounts m ()
[GetAccount] :: Address -> Accounts m (Maybe Account)
type AuthEffs = '[Accounts, Error AuthError]
createAccount :: forall r_a21bE. MemberWithError Accounts r_a21bE => Address -> Sem r_a21bE Account
updateAccount :: forall r_a21bG. MemberWithError Accounts r_a21bG => Address -> (Account -> Account) -> Sem r_a21bG ()
getAccount :: forall r_a21bJ. MemberWithError Accounts r_a21bJ => Address -> Sem r_a21bJ (Maybe Account)
eval :: Members [ReadStore, WriteStore, Error AppError] r => Sem (Accounts : (Error AuthError : r)) a -> Sem r a

-- | Query API
type Api = "accounts" :> StoreLeaf (Map Address Account)
querier :: Members QueryEffs r => RouteQ Api r
data Account
Account :: [Coin] -> Word64 -> Account
[accountCoins] :: Account -> [Coin]
[accountNonce] :: Account -> Word64
data Coin
Coin :: CoinId -> Amount -> Coin
[coinId] :: Coin -> CoinId
[coinAmount] :: Coin -> Amount
newtype Amount
Amount :: Word64 -> Amount
[unAmount] :: Amount -> Word64
newtype CoinId
CoinId :: Text -> CoinId
[unCoinId] :: CoinId -> Text
data AuthError
AccountAlreadyExists :: Address -> AuthError
AccountNotFound :: Address -> AuthError
type AuthName = "auth"
coinAesonOptions :: Options

-- | Used as a unique identifier for an account.
newtype Address
Address :: HexString -> Address

module Tendermint.SDK.Application.AnteHandler
createAccountAnteHandler :: Members AuthEffs r => AnteHandler r
nonceAnteHandler :: Members AuthEffs r => Member (Error AppError) r => AnteHandler r
baseAppAnteHandler :: Members AuthEffs r => Member (Error AppError) r => AnteHandler r
type AnteHandler r = forall msg a. (Endo (RoutingTx msg -> Sem r a))

module Tendermint.SDK.Application.Handlers
type Handler mt r = Request mt -> Sem r (Response mt)
data HandlersContext alg ms core
HandlersContext :: Proxy alg -> ModuleList ms (Effs ms core) -> (BeginBlock -> Sem (Effs ms core) ()) -> (EndBlock -> Sem (Effs ms core) EndBlockResult) -> AnteHandler (Effs ms core) -> (forall a. Sem (BaseAppEffs core) a -> Sem core a) -> HandlersContext alg ms core
[signatureAlgP] :: HandlersContext alg ms core -> Proxy alg
[modules] :: HandlersContext alg ms core -> ModuleList ms (Effs ms core)
[beginBlocker] :: HandlersContext alg ms core -> BeginBlock -> Sem (Effs ms core) ()
[endBlocker] :: HandlersContext alg ms core -> EndBlock -> Sem (Effs ms core) EndBlockResult
[anteHandler] :: HandlersContext alg ms core -> AnteHandler (Effs ms core)
[compileToCore] :: HandlersContext alg ms core -> forall a. Sem (BaseAppEffs core) a -> Sem core a
makeApp :: forall alg ms core. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => Member (Embed IO) core => ToApplication ms (Effs ms core) => HasTxRouter (ApplicationC ms) (Effs ms core) 'QueryAndMempool => HasTxRouter (ApplicationC ms) (BaseAppEffs core) 'QueryAndMempool => HasTxRouter (ApplicationD ms) (Effs ms core) 'Consensus => HasTxRouter (ApplicationD ms) (BaseAppEffs core) 'Consensus => HasQueryRouter (ApplicationQ ms) (Effs ms core) => HasQueryRouter (ApplicationQ ms) (BaseAppEffs core) => Eval ms core => HandlersContext alg ms core -> App (Sem core)

module Tendermint.SDK.Application
data ModuleList (ms :: [Component]) r
[NilModules] :: ModuleList '[] r
[:+] :: Module name check deliver query es deps r -> ModuleList ms r -> ModuleList (Module name check deliver query es deps : ms) r
infixr 5 :+
data Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow)
Module :: RouteTx check r -> RouteTx deliver r -> RouteQ query r -> (forall s. (Members TxEffs s, Members BaseEffs s, Members (DependencyEffs deps) s) => forall a. Sem (es :& s) a -> Sem s a) -> Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow)
[moduleTxChecker] :: Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow) -> RouteTx check r
[moduleTxDeliverer] :: Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow) -> RouteTx deliver r
[moduleQuerier] :: Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow) -> RouteQ query r
[moduleEval] :: Module (name :: Symbol) (check :: Type) (deliver :: Type) (query :: Type) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow) -> forall s. (Members TxEffs s, Members BaseEffs s, Members (DependencyEffs deps) s) => forall a. Sem (es :& s) a -> Sem s a
type Component = EffectRow -> Type
class Eval ms (core :: EffectRow) where {
    type family Effs ms core :: EffectRow;
}
eval :: Eval ms core => proxy core -> ModuleList ms r -> forall a. Sem (Effs ms core) a -> Sem (TxEffs :& BaseAppEffs core) a
type family ModuleEffs (m :: Component) :: EffectRow
data HandlersContext alg ms core
HandlersContext :: Proxy alg -> ModuleList ms (Effs ms core) -> (BeginBlock -> Sem (Effs ms core) ()) -> (EndBlock -> Sem (Effs ms core) EndBlockResult) -> AnteHandler (Effs ms core) -> (forall a. Sem (BaseAppEffs core) a -> Sem core a) -> HandlersContext alg ms core
[signatureAlgP] :: HandlersContext alg ms core -> Proxy alg
[modules] :: HandlersContext alg ms core -> ModuleList ms (Effs ms core)
[beginBlocker] :: HandlersContext alg ms core -> BeginBlock -> Sem (Effs ms core) ()
[endBlocker] :: HandlersContext alg ms core -> EndBlock -> Sem (Effs ms core) EndBlockResult
[anteHandler] :: HandlersContext alg ms core -> AnteHandler (Effs ms core)
[compileToCore] :: HandlersContext alg ms core -> forall a. Sem (BaseAppEffs core) a -> Sem core a
baseAppAnteHandler :: Members AuthEffs r => Member (Error AppError) r => AnteHandler r
createIOApp :: forall r. (forall a. Sem r a -> IO a) -> App (Sem r) -> App IO
makeApp :: forall alg ms core. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => Member (Embed IO) core => ToApplication ms (Effs ms core) => HasTxRouter (ApplicationC ms) (Effs ms core) 'QueryAndMempool => HasTxRouter (ApplicationC ms) (BaseAppEffs core) 'QueryAndMempool => HasTxRouter (ApplicationD ms) (Effs ms core) 'Consensus => HasTxRouter (ApplicationD ms) (BaseAppEffs core) 'Consensus => HasQueryRouter (ApplicationQ ms) (Effs ms core) => HasQueryRouter (ApplicationQ ms) (BaseAppEffs core) => Eval ms core => HandlersContext alg ms core -> App (Sem core)

module Tendermint.SDK.Modules.Validators
type Validators = Module ValidatorsName EmptyTxServer EmptyTxServer QueryApi ValidatorsEffs '[]
validatorsModule :: Members (ModuleEffs Validators) r => Validators r
data ValidatorsKeeper m a
[GetValidatorsKeys] :: ValidatorsKeeper m (Set PubKey_)
[GetPowerOf] :: PubKey_ -> ValidatorsKeeper m Word64
[GetQueuedUpdates] :: ValidatorsKeeper m (Map PubKey_ Word64)
[QueueUpdate] :: PubKey_ -> Word64 -> ValidatorsKeeper m ()
queueUpdate :: forall r_a1W0d. MemberWithError ValidatorsKeeper r_a1W0d => PubKey_ -> Word64 -> Sem r_a1W0d ()
getQueuedUpdates :: forall r_a1W0c. MemberWithError ValidatorsKeeper r_a1W0c => Sem r_a1W0c (Map PubKey_ Word64)
getPowerOf :: forall r_a1W0a. MemberWithError ValidatorsKeeper r_a1W0a => PubKey_ -> Sem r_a1W0a Word64
getValidatorsKeys :: forall r_a1W09. MemberWithError ValidatorsKeeper r_a1W09 => Sem r_a1W09 (Set PubKey_)
type ValidatorsEffs = '[ValidatorsKeeper]
eval :: Members [ReadStore, WriteStore, Error AppError] r => Sem (ValidatorsKeeper : r) a -> Sem r a
getValidatorsKeysF :: Members [ReadStore, Error AppError] r => Sem r (Set PubKey_)
getPowerOfF :: Members [ReadStore, Error AppError] r => PubKey_ -> Sem r Word64
getQueuedUpdatesF :: Members [ReadStore, Error AppError] r => Sem r (Map PubKey_ Word64)
queueUpdateF :: Members [ReadStore, WriteStore, Error AppError] r => PubKey_ -> Word64 -> Sem r ()
data ValidatorsNameSpace
type ValidatorsName = "validators"
updatesListKey :: ByteString
validatorsMapKey :: ByteString
validatorsKeySetKey :: ByteString
newtype ValidatorUpdate_
ValidatorUpdate_ :: ValidatorUpdate -> ValidatorUpdate_
newtype PubKey_
PubKey_ :: PubKey -> PubKey_
newtype KeySet
KeySet :: Set PubKey_ -> KeySet
endBlock :: Members BlockEffs r => Members ValidatorsEffs r => EndBlock -> Sem r EndBlockResult

module Tendermint.SDK.Modules.Bank
type Bank = Module BankName MessageApi MessageApi QueryApi BankEffs '[Auth]
bankModule :: Members (ModuleEffs Bank) r => Bank r
type BankEffs = '[BankKeeper, Error BankError]
data BankKeeper m a
[GetBalance] :: Address -> CoinId -> BankKeeper m Coin
[Transfer] :: Address -> Coin -> Address -> BankKeeper m ()
[Burn] :: Address -> Coin -> BankKeeper m ()
[Mint] :: Address -> Coin -> BankKeeper m ()
getBalance :: forall r_a272A. MemberWithError BankKeeper r_a272A => Address -> CoinId -> Sem r_a272A Coin
transfer :: forall r_a272D. MemberWithError BankKeeper r_a272D => Address -> Coin -> Address -> Sem r_a272D ()
burn :: forall r_a272H. MemberWithError BankKeeper r_a272H => Address -> Coin -> Sem r_a272H ()
mint :: forall r_a272K. MemberWithError BankKeeper r_a272K => Address -> Coin -> Sem r_a272K ()
eval :: Members [Logger, Output Event, Error AppError] r => Members AuthEffs r => forall a. Sem (BankKeeper : (Error BankError : r)) a -> Sem r a
data TransferMsg
TransferMsg :: Address -> Address -> CoinId -> Amount -> TransferMsg
[transferTo] :: TransferMsg -> Address
[transferFrom] :: TransferMsg -> Address
[transferCoinId] :: TransferMsg -> CoinId
[transferAmount] :: TransferMsg -> Amount
data BurnMsg
BurnMsg :: Address -> CoinId -> Amount -> BurnMsg
[burnAddress] :: BurnMsg -> Address
[burnCoinId] :: BurnMsg -> CoinId
[burnAmount] :: BurnMsg -> Amount

-- | Query Api
type GetAddressCoinBalance = "balance" :> QA Address :> QueryParam' '[Required, Strict] "coin_id" CoinId :> Leaf Coin
getAddressCoinBalance :: Member BankKeeper r => QueryArgs Address -> CoinId -> Sem r (QueryResult Coin)
type QueryApi = GetAddressCoinBalance
querier :: forall r. Member BankKeeper r => RouteQ QueryApi r
type MessageApi = TypedMessage BurnMsg :~> Return () :<|> TypedMessage TransferMsg :~> Return ()
messageHandlers :: Members BankEffs r => RouteTx MessageApi r
data TransferEvent
TransferEvent :: CoinId -> Amount -> Address -> Address -> TransferEvent
[transferEventCoinId] :: TransferEvent -> CoinId
[transferEventAmount] :: TransferEvent -> Amount
[transferEventTo] :: TransferEvent -> Address
[transferEventFrom] :: TransferEvent -> Address
data BankError
InsufficientFunds :: Text -> BankError
type BankName = "bank"
transferEventAesonOptions :: Options
newtype Amount
Amount :: Word64 -> Amount
[unAmount] :: Amount -> Word64
data Coin
Coin :: CoinId -> Amount -> Coin
[coinId] :: Coin -> CoinId
[coinAmount] :: Coin -> Amount
newtype CoinId
CoinId :: Text -> CoinId
[unCoinId] :: CoinId -> Text
