-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/f-o-a-m/kepler/blob/master/hs-abci-sdk/README.md</a>
@package hs-abci-sdk
@version 0.1.0.0

module Proto.Modules.Auth

-- | Fields :
--   
--   <ul>
--   <li><a>coins</a> <tt>:: Lens' Account [Coin]</tt></li>
--   <li><a>vec'coins</a> <tt>:: Lens' Account (Data.Vector.Vector
--   Coin)</tt></li>
--   <li><a>nonce</a> <tt>:: Lens' Account Data.Word.Word64</tt></li>
--   </ul>
data Account

-- | Fields :
--   
--   <ul>
--   <li><a>amount</a> <tt>:: Lens' Amount Data.Word.Word64</tt></li>
--   </ul>
data Amount

-- | Fields :
--   
--   <ul>
--   <li><a>id</a> <tt>:: Lens' Coin CoinId</tt></li>
--   <li><a>maybe'id</a> <tt>:: Lens' Coin (Prelude.Maybe CoinId)</tt></li>
--   <li><a>amount</a> <tt>:: Lens' Coin Amount</tt></li>
--   <li><a>maybe'amount</a> <tt>:: Lens' Coin (Prelude.Maybe
--   Amount)</tt></li>
--   </ul>
data Coin

-- | Fields :
--   
--   <ul>
--   <li><a>id</a> <tt>:: Lens' CoinId Data.Text.Text</tt></li>
--   </ul>
data CoinId
instance GHC.Classes.Ord Proto.Modules.Auth.Account
instance GHC.Classes.Eq Proto.Modules.Auth.Account
instance GHC.Classes.Ord Proto.Modules.Auth.Coin
instance GHC.Classes.Eq Proto.Modules.Auth.Coin
instance GHC.Classes.Ord Proto.Modules.Auth.CoinId
instance GHC.Classes.Eq Proto.Modules.Auth.CoinId
instance GHC.Classes.Ord Proto.Modules.Auth.Amount
instance GHC.Classes.Eq Proto.Modules.Auth.Amount
instance GHC.Show.Show Proto.Modules.Auth.Account
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Account "coins" [Proto.Modules.Auth.Coin]
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Account "vec'coins" (Data.Vector.Vector Proto.Modules.Auth.Coin)
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Account "nonce" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.Account
instance Control.DeepSeq.NFData Proto.Modules.Auth.Account
instance GHC.Show.Show Proto.Modules.Auth.Coin
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "id" Proto.Modules.Auth.CoinId
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "maybe'id" (GHC.Maybe.Maybe Proto.Modules.Auth.CoinId)
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "amount" Proto.Modules.Auth.Amount
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Coin "maybe'amount" (GHC.Maybe.Maybe Proto.Modules.Auth.Amount)
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.Coin
instance Control.DeepSeq.NFData Proto.Modules.Auth.Coin
instance GHC.Show.Show Proto.Modules.Auth.CoinId
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.CoinId "id" Data.Text.Internal.Text
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.CoinId
instance Control.DeepSeq.NFData Proto.Modules.Auth.CoinId
instance GHC.Show.Show Proto.Modules.Auth.Amount
instance Data.ProtoLens.Field.HasField Proto.Modules.Auth.Amount "amount" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Auth.Amount
instance Control.DeepSeq.NFData Proto.Modules.Auth.Amount

module Proto.Modules.Auth_Fields
amount :: forall f s a. (Functor f, HasField s "amount" a) => LensLike' f s a
coins :: forall f s a. (Functor f, HasField s "coins" a) => LensLike' f s a
id :: forall f s a. (Functor f, HasField s "id" a) => LensLike' f s a
maybe'amount :: forall f s a. (Functor f, HasField s "maybe'amount" a) => LensLike' f s a
maybe'id :: forall f s a. (Functor f, HasField s "maybe'id" a) => LensLike' f s a
nonce :: forall f s a. (Functor f, HasField s "nonce" a) => LensLike' f s a
vec'coins :: forall f s a. (Functor f, HasField s "vec'coins" a) => LensLike' f s a

module Proto.Modules.Bank

-- | Fields :
--   
--   <ul>
--   <li><a>address</a> <tt>:: Lens' Burn
--   Data.ByteString.ByteString</tt></li>
--   <li><a>cid</a> <tt>:: Lens' Burn Data.Text.Text</tt></li>
--   <li><a>amount</a> <tt>:: Lens' Burn Data.Word.Word64</tt></li>
--   </ul>
data Burn

-- | Fields :
--   
--   <ul>
--   <li><a>to</a> <tt>:: Lens' Transfer
--   Data.ByteString.ByteString</tt></li>
--   <li><a>from</a> <tt>:: Lens' Transfer
--   Data.ByteString.ByteString</tt></li>
--   <li><a>cid</a> <tt>:: Lens' Transfer Data.Text.Text</tt></li>
--   <li><a>amount</a> <tt>:: Lens' Transfer Data.Word.Word64</tt></li>
--   </ul>
data Transfer
instance GHC.Classes.Ord Proto.Modules.Bank.Transfer
instance GHC.Classes.Eq Proto.Modules.Bank.Transfer
instance GHC.Classes.Ord Proto.Modules.Bank.Burn
instance GHC.Classes.Eq Proto.Modules.Bank.Burn
instance GHC.Show.Show Proto.Modules.Bank.Transfer
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Transfer "to" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Transfer "from" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Transfer "cid" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Transfer "amount" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Bank.Transfer
instance Control.DeepSeq.NFData Proto.Modules.Bank.Transfer
instance GHC.Show.Show Proto.Modules.Bank.Burn
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Burn "address" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Burn "cid" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Modules.Bank.Burn "amount" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Modules.Bank.Burn
instance Control.DeepSeq.NFData Proto.Modules.Bank.Burn

module Proto.Modules.Bank_Fields
address :: forall f s a. (Functor f, HasField s "address" a) => LensLike' f s a
amount :: forall f s a. (Functor f, HasField s "amount" a) => LensLike' f s a
cid :: forall f s a. (Functor f, HasField s "cid" a) => LensLike' f s a
from :: forall f s a. (Functor f, HasField s "from" a) => LensLike' f s a
to :: forall f s a. (Functor f, HasField s "to" a) => LensLike' f s a

module Proto.Types.Transaction

-- | Fields :
--   
--   <ul>
--   <li><a>data'</a> <tt>:: Lens' RawTransaction TypedMessage</tt></li>
--   <li><a>maybe'data'</a> <tt>:: Lens' RawTransaction (Prelude.Maybe
--   TypedMessage)</tt></li>
--   <li><a>gas</a> <tt>:: Lens' RawTransaction Data.Int.Int64</tt></li>
--   <li><a>signature</a> <tt>:: Lens' RawTransaction
--   Data.ByteString.ByteString</tt></li>
--   <li><a>route</a> <tt>:: Lens' RawTransaction Data.Text.Text</tt></li>
--   <li><a>nonce</a> <tt>:: Lens' RawTransaction
--   Data.Word.Word64</tt></li>
--   </ul>
data RawTransaction

-- | Fields :
--   
--   <ul>
--   <li><a>type'</a> <tt>:: Lens' TypedMessage Data.Text.Text</tt></li>
--   <li><a>data'</a> <tt>:: Lens' TypedMessage
--   Data.ByteString.ByteString</tt></li>
--   </ul>
data TypedMessage
instance GHC.Classes.Ord Proto.Types.Transaction.RawTransaction
instance GHC.Classes.Eq Proto.Types.Transaction.RawTransaction
instance GHC.Classes.Ord Proto.Types.Transaction.TypedMessage
instance GHC.Classes.Eq Proto.Types.Transaction.TypedMessage
instance GHC.Show.Show Proto.Types.Transaction.RawTransaction
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "data'" Proto.Types.Transaction.TypedMessage
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "maybe'data'" (GHC.Maybe.Maybe Proto.Types.Transaction.TypedMessage)
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "gas" GHC.Int.Int64
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "signature" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "route" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.RawTransaction "nonce" GHC.Word.Word64
instance Data.ProtoLens.Message.Message Proto.Types.Transaction.RawTransaction
instance Control.DeepSeq.NFData Proto.Types.Transaction.RawTransaction
instance GHC.Show.Show Proto.Types.Transaction.TypedMessage
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.TypedMessage "type'" Data.Text.Internal.Text
instance Data.ProtoLens.Field.HasField Proto.Types.Transaction.TypedMessage "data'" Data.ByteString.Internal.ByteString
instance Data.ProtoLens.Message.Message Proto.Types.Transaction.TypedMessage
instance Control.DeepSeq.NFData Proto.Types.Transaction.TypedMessage

module Proto.Types.Transaction_Fields
data' :: forall f s a. (Functor f, HasField s "data'" a) => LensLike' f s a
gas :: forall f s a. (Functor f, HasField s "gas" a) => LensLike' f s a
maybe'data' :: forall f s a. (Functor f, HasField s "maybe'data'" a) => LensLike' f s a
nonce :: forall f s a. (Functor f, HasField s "nonce" a) => LensLike' f s a
route :: forall f s a. (Functor f, HasField s "route" a) => LensLike' f s a
signature :: forall f s a. (Functor f, HasField s "signature" a) => LensLike' f s a
type' :: forall f s a. (Functor f, HasField s "type'" a) => LensLike' f s a

module Tendermint.SDK.BaseApp.Logger

-- | Effect allowing for console logging.
data Logger m a
[Log] :: Severity -> Text -> Logger m ()
[AddContext] :: (Select x, ToJSON x) => x -> m a -> Logger m a
log :: forall r_aCqy. MemberWithError Logger r_aCqy => Severity -> Text -> Sem r_aCqy ()

-- | Class for selecting object keys for contextual logging
class Select a
select :: Select a => Verbosity -> a -> LogSelect
select :: Select a => Verbosity -> a -> LogSelect
addContext :: forall r_aCqB x_XB4x a_aB4y. (MemberWithError Logger r_aCqB, Select x_XB4x, ToJSON x_XB4x) => x_XB4x -> Sem r_aCqB a_aB4y -> Sem r_aCqB a_aB4y
data LogSelect
All :: LogSelect
Some :: [Text] -> LogSelect
data Severity
Debug :: Severity
Info :: Severity
Warning :: Severity
Error :: Severity
Exception :: Severity
data Verbosity
V0 :: Verbosity
V1 :: Verbosity
V2 :: Verbosity
V3 :: Verbosity
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Logger.Severity
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Logger.Severity

module Tendermint.SDK.BaseApp.Events

-- | A class representing a type that can be emitted as an event in the |
--   event logs for the deliverTx response.
class ToEvent e
makeEventType :: ToEvent e => Proxy e -> String
makeEventData :: ToEvent e => e -> [(ByteString, ByteString)]
makeEventData :: (ToEvent e, ToJSON e) => e -> [(ByteString, ByteString)]

-- | Special event wrapper to add contextual event_type info
newtype ContextEvent t
ContextEvent :: t -> ContextEvent t
makeEvent :: ToEvent e => e -> Event
emit :: ToEvent e => Member (Output Event) r => e -> Sem r ()
logEvent :: forall e r. (ToJSON e, ToEvent e, Select e) => Member Logger r => e -> Sem r ()
data Event
Event :: Text -> [KVPair] -> Event

-- | Type of Event
[eventType] :: Event -> Text

-- | Event attributes
[eventAttributes] :: Event -> [KVPair]
instance (Data.Aeson.Types.ToJSON.ToJSON a, Tendermint.SDK.BaseApp.Events.ToEvent a) => Data.Aeson.Types.ToJSON.ToJSON (Tendermint.SDK.BaseApp.Events.ContextEvent a)
instance Tendermint.SDK.BaseApp.Logger.Select a => Tendermint.SDK.BaseApp.Logger.Select (Tendermint.SDK.BaseApp.Events.ContextEvent a)

module Tendermint.SDK.BaseApp.Logger.Katip
data LogConfig
LogConfig :: Namespace -> LogContexts -> LogEnv -> LogConfig
[_logNamespace] :: LogConfig -> Namespace
[_logContext] :: LogConfig -> LogContexts
[_logEnv] :: LogConfig -> LogEnv
logNamespace :: Lens' LogConfig Namespace
logContext :: Lens' LogConfig LogContexts
logEnv :: Lens' LogConfig LogEnv
data InitialLogNamespace
InitialLogNamespace :: Text -> Text -> InitialLogNamespace
[_initialLogEnvironment] :: InitialLogNamespace -> Text
[_initialLogProcessName] :: InitialLogNamespace -> Text
initialLogEnvironment :: Lens' InitialLogNamespace Text
initialLogProcessName :: Lens' InitialLogNamespace Text
evalKatip :: forall r a. KatipContext (Sem r) => Sem (Logger : r) a -> Sem r a
instance Polysemy.Internal.Members '[Polysemy.Embed.Type.Embed GHC.Types.IO, Polysemy.Reader.Reader Tendermint.SDK.BaseApp.Logger.Katip.LogConfig] r => Katip.Core.Katip (Polysemy.Internal.Sem r)
instance Polysemy.Internal.Members '[Polysemy.Embed.Type.Embed GHC.Types.IO, Polysemy.Reader.Reader Tendermint.SDK.BaseApp.Logger.Katip.LogConfig] r => Katip.Monadic.KatipContext (Polysemy.Internal.Sem r)
instance Tendermint.SDK.BaseApp.Logger.Select a => Tendermint.SDK.BaseApp.Logger.Select (Tendermint.SDK.BaseApp.Logger.Katip.Object a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Katip.Core.ToObject (Tendermint.SDK.BaseApp.Logger.Katip.Object a)
instance (Data.Aeson.Types.ToJSON.ToJSON a, Tendermint.SDK.BaseApp.Logger.Select a) => Katip.Core.LogItem (Tendermint.SDK.BaseApp.Logger.Katip.Object a)

module Tendermint.SDK.BaseApp.Metrics
data CountName
CountName :: Text -> [(Text, Text)] -> CountName
[countName] :: CountName -> Text
[countLabels] :: CountName -> [(Text, Text)]
data HistogramName
HistogramName :: Text -> [(Text, Text)] -> [Double] -> HistogramName
[histogramName] :: HistogramName -> Text
[histogramLabels] :: HistogramName -> [(Text, Text)]
[histogramBuckets] :: HistogramName -> [Double]
data Metrics m a

-- | Increments the count of a specific message
[IncCount] :: CountName -> Metrics m ()

-- | Times an action and records it in a histogram
[WithTimer] :: HistogramName -> m a -> Metrics m a
withTimer :: forall r_aQSJ a_aQHF. MemberWithError Metrics r_aQSJ => HistogramName -> Sem r_aQSJ a_aQHF -> Sem r_aQSJ a_aQHF
incCount :: forall r_aQSH. MemberWithError Metrics r_aQSH => CountName -> Sem r_aQSH ()
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Metrics.HistogramName
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Metrics.HistogramName
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Metrics.CountName
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Metrics.CountName
instance Data.String.IsString Tendermint.SDK.BaseApp.Metrics.HistogramName
instance Data.String.IsString Tendermint.SDK.BaseApp.Metrics.CountName

module Tendermint.SDK.BaseApp.Metrics.Prometheus

-- | Core metrics config
data MetricsScrapingConfig
MetricsScrapingConfig :: Int -> MetricsScrapingConfig
[_prometheusPort] :: MetricsScrapingConfig -> Int
prometheusPort :: Iso' MetricsScrapingConfig Int
data MetricsState
MetricsState :: Registry -> MVar (MetricsMap Counter) -> MVar (MetricsMap Histogram) -> MetricsState
[_metricsRegistry] :: MetricsState -> Registry
[_metricsCounters] :: MetricsState -> MVar (MetricsMap Counter)
[_metricsHistograms] :: MetricsState -> MVar (MetricsMap Histogram)
metricsRegistry :: Lens' MetricsState Registry
metricsCounters :: Lens' MetricsState (MVar (MetricsMap Counter))
metricsHistograms :: Lens' MetricsState (MVar (MetricsMap Histogram))
data PrometheusEnv
PrometheusEnv :: MetricsState -> MetricsScrapingConfig -> PrometheusEnv
[_envMetricsState] :: PrometheusEnv -> MetricsState
[_envMetricsScrapingConfig] :: PrometheusEnv -> MetricsScrapingConfig
envMetricsState :: Lens' PrometheusEnv MetricsState
envMetricsScrapingConfig :: Lens' PrometheusEnv MetricsScrapingConfig
emptyState :: IO MetricsState
forkMetricsServer :: MonadIO m => PrometheusEnv -> m ThreadId

-- | Prometheus registry index key
mkPrometheusMetricId :: MetricIdentifier -> MetricId

-- | Index key for storing metrics
metricIdStorable :: MetricIdentifier -> (Text, Labels)
countToIdentifier :: CountName -> MetricIdentifier
histogramToIdentifier :: HistogramName -> MetricIdentifier
evalWithMetrics :: Member (Embed IO) r => Member (Reader (Maybe PrometheusEnv)) r => Sem (Metrics : r) a -> Sem r a
evalNothing :: Sem (Metrics : r) a -> Sem r a

-- | Increments existing count, if it doesn't exist, creates a new |
--   counter and increments it.
evalMetrics :: Member (Embed IO) r => MetricsState -> Sem (Metrics : r) a -> Sem r a
instance Data.String.IsString Tendermint.SDK.BaseApp.Metrics.Prometheus.MetricIdentifier

module Tendermint.SDK.Codec

-- | This class is used as a codec for all items stored in | the database
--   as well as incoming transaction messages.
class HasCodec a
encode :: HasCodec a => a -> ByteString
decode :: HasCodec a => ByteString -> Either Text a
defaultSDKAesonOptions :: String -> Options
instance Tendermint.SDK.Codec.HasCodec ()

module Tendermint.SDK.Types.Address

-- | Used as a unique identifier for an account.
newtype Address
Address :: HexString -> Address
addressToBytes :: Address -> ByteString
addressFromBytes :: ByteString -> Address
pubKeyToAddress :: PubKey -> Address
instance Data.Aeson.Types.FromJSON.FromJSON Tendermint.SDK.Types.Address.Address
instance Data.Aeson.Types.ToJSON.ToJSON Tendermint.SDK.Types.Address.Address
instance GHC.Classes.Ord Tendermint.SDK.Types.Address.Address
instance GHC.Generics.Generic Tendermint.SDK.Types.Address.Address
instance GHC.Show.Show Tendermint.SDK.Types.Address.Address
instance GHC.Classes.Eq Tendermint.SDK.Types.Address.Address
instance Proto3.Suite.Class.Primitive Tendermint.SDK.Types.Address.Address
instance Proto3.Suite.Class.HasDefault Tendermint.SDK.Types.Address.Address
instance Proto3.Suite.Class.MessageField Tendermint.SDK.Types.Address.Address
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Types.Address.Address
instance Web.Internal.HttpApiData.ToHttpApiData Tendermint.SDK.Types.Address.Address
instance Web.Internal.HttpApiData.FromHttpApiData Tendermint.SDK.Types.Address.Address
instance Proto3.Suite.Class.HasDefault Data.ByteArray.HexString.HexString

module Tendermint.SDK.Crypto

-- | Class encapsulating data which can hashed.
class MakeDigest a
makeDigest :: MakeDigest a => a -> Digest SHA256

-- | Defines the types and methods for the signature schema parameterized
--   by <tt>alg</tt>.
class SignatureSchema alg where {
    type family PubKey alg :: *;
    type family PrivateKey alg :: *;
    type family Signature alg :: *;
    type family Message alg :: *;
}
algorithm :: SignatureSchema alg => Proxy alg -> Text
sign :: SignatureSchema alg => Proxy alg -> PrivateKey alg -> Message alg -> Signature alg
verify :: SignatureSchema alg => Proxy alg -> PubKey alg -> Signature alg -> Message alg -> Bool
makePubKey :: SignatureSchema alg => Proxy alg -> ByteString -> Maybe (PubKey alg)
makeSignature :: SignatureSchema alg => Proxy alg -> ByteString -> Maybe (Signature alg)
derivePubKey :: SignatureSchema alg => Proxy alg -> PrivateKey alg -> PubKey alg
addressFromPubKey :: SignatureSchema alg => Proxy alg -> PubKey alg -> Address

-- | Class allowing for signing and recovering signatures for messages.
class SignatureSchema alg => RecoverableSignatureSchema alg where {
    type family RecoverableSignature alg :: *;
}
signRecoverableMessage :: RecoverableSignatureSchema alg => Proxy alg -> PrivateKey alg -> Message alg -> RecoverableSignature alg
recover :: RecoverableSignatureSchema alg => Proxy alg -> RecoverableSignature alg -> Message alg -> Maybe (PubKey alg)
serializeRecoverableSignature :: RecoverableSignatureSchema alg => Proxy alg -> RecoverableSignature alg -> ByteString
makeRecoverableSignature :: RecoverableSignatureSchema alg => Proxy alg -> ByteString -> Maybe (RecoverableSignature alg)
parsePubKey :: SignatureSchema alg => Proxy alg -> PubKey -> Either Text (PubKey alg)
data Secp256k1
instance Tendermint.SDK.Crypto.SignatureSchema Tendermint.SDK.Crypto.Secp256k1
instance Tendermint.SDK.Crypto.RecoverableSignatureSchema Tendermint.SDK.Crypto.Secp256k1

module Tendermint.SDK.Types.Effects

-- | This type family gives a nice syntax for combining multiple lists of
--   effects.
type family (as :: [a]) :& (bs :: [a]) :: [a]
infixr 5 :&

module Tendermint.SDK.Types.Message

-- | The basic message format embedded in any transaction.
data Msg msg
Msg :: Address -> msg -> Text -> Msg msg
[msgAuthor] :: Msg msg -> Address
[msgData] :: Msg msg -> msg
[msgType] :: Msg msg -> Text
class HasMessageType msg
messageType :: HasMessageType msg => Proxy msg -> Text
data TypedMessage
TypedMessage :: ByteString -> Text -> TypedMessage
[typedMsgData] :: TypedMessage -> ByteString
[typedMsgType] :: TypedMessage -> Text

-- | This is a general error type, primarily accomodating protobuf messages
--   being parsed | by either the <a>proto3-wire</a> | or the
--   <a>proto-lens</a> libraries.
data MessageParseError

-- | A <a>WireTypeError</a> occurs when the type of the data in the
--   protobuf binary format does not match the type encountered by the
--   parser.
WireTypeError :: Text -> MessageParseError

-- | A <a>BinaryError</a> occurs when we can't successfully parse the
--   contents of the field.
BinaryError :: Text -> MessageParseError

-- | An <a>EmbeddedError</a> occurs when we encounter an error while
--   parsing an embedded message.
EmbeddedError :: Text -> Maybe MessageParseError -> MessageParseError

-- | Unknown or unstructured parsing error.
OtherParseError :: Text -> MessageParseError

-- | Useful for returning in error logs or console logging.
formatMessageParseError :: MessageParseError -> Text
coerceProto3Error :: ParseError -> MessageParseError
coerceProtoLensError :: String -> MessageParseError

-- | Used during message validation to indicate that although the message
--   has parsed | correctly, it fails certain sanity checks.
data MessageSemanticError

-- | Used to indicate that the message signer does not have the authority
--   to send | this message.
PermissionError :: Text -> MessageSemanticError

-- | Used to indicate that a field isn't valid, e.g. enforces non-negative
--   quantities | or nonempty lists.
InvalidFieldError :: Text -> MessageSemanticError
OtherSemanticError :: Text -> MessageSemanticError
formatMessageSemanticError :: MessageSemanticError -> Text
class ValidateMessage msg
validateMessage :: ValidateMessage msg => Msg msg -> Validation [MessageSemanticError] ()
nonEmptyCheck :: Eq a => Monoid a => Text -> a -> Validation [MessageSemanticError] ()
isAuthorCheck :: Text -> Msg msg -> (msg -> Address) -> Validation [MessageSemanticError] ()
instance Control.Lens.Wrapped.Wrapped Tendermint.SDK.Types.Message.TypedMessage
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Types.Message.TypedMessage
instance GHC.Base.Functor Tendermint.SDK.Types.Message.Msg

module Tendermint.SDK.Types.Transaction
data Tx alg msg
Tx :: Msg msg -> Text -> Int64 -> RecoverableSignature alg -> Message alg -> PubKey alg -> Word64 -> Tx alg msg
[txMsg] :: Tx alg msg -> Msg msg
[txRoute] :: Tx alg msg -> Text
[txGas] :: Tx alg msg -> Int64
[txSignature] :: Tx alg msg -> RecoverableSignature alg
[txSignBytes] :: Tx alg msg -> Message alg
[txSigner] :: Tx alg msg -> PubKey alg
[txNonce] :: Tx alg msg -> Word64

-- | Raw transaction type coming in over the wire
data RawTransaction
RawTransaction :: TypedMessage -> Int64 -> Text -> ByteString -> Word64 -> RawTransaction

-- | the encoded message via protobuf encoding
[rawTransactionData] :: RawTransaction -> TypedMessage
[rawTransactionGas] :: RawTransaction -> Int64

-- | module name
[rawTransactionRoute] :: RawTransaction -> Text
[rawTransactionSignature] :: RawTransaction -> ByteString
[rawTransactionNonce] :: RawTransaction -> Word64
signRawTransaction :: forall alg. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => Proxy alg -> PrivateKey alg -> RawTransaction -> RecoverableSignature alg

-- | Attempt to parse a Bytestring into a <a>RawTransaction</a> then as a
--   <a>Tx</a> without | attempting to parse the underlying message. This
--   is done as a preprocessing | step to the router, allowing for failure
--   before the router is ever | reached.
parseTx :: forall alg. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => Proxy alg -> ByteString -> Either Text (Tx alg ByteString)
instance GHC.Generics.Generic Tendermint.SDK.Types.Transaction.RawTransaction
instance Control.Lens.Wrapped.Wrapped Tendermint.SDK.Types.Transaction.RawTransaction
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Types.Transaction.RawTransaction
instance Tendermint.SDK.Crypto.MakeDigest Tendermint.SDK.Types.Transaction.RawTransaction
instance forall k (alg :: k). GHC.Base.Functor (Tendermint.SDK.Types.Transaction.Tx alg)

module Tendermint.SDK.Types.TxResult

-- | This type represents a common transaction result for the CheckTx | and
--   DeliverTx abci-messages.
data TxResult
TxResult :: Base64String -> Text -> Int64 -> Int64 -> [Event] -> Word32 -> Text -> Text -> TxResult
[_txResultData] :: TxResult -> Base64String
[_txResultInfo] :: TxResult -> Text
[_txResultGasWanted] :: TxResult -> Int64
[_txResultGasUsed] :: TxResult -> Int64
[_txResultEvents] :: TxResult -> [Event]
[_txResultCode] :: TxResult -> Word32
[_txResultLog] :: TxResult -> Text
[_txResultCodespace] :: TxResult -> Text
txResultLog :: Lens' TxResult Text
txResultInfo :: Lens' TxResult Text
txResultGasWanted :: Lens' TxResult Int64
txResultGasUsed :: Lens' TxResult Int64
txResultEvents :: Lens' TxResult [Event]
txResultData :: Lens' TxResult Base64String
txResultCodespace :: Lens' TxResult Text
txResultCode :: Lens' TxResult Word32

-- | This class is used to set the <a>TxResult</a> data into the
--   appropriate | response fields for the CheckTx abci-message.
checkTxTxResult :: Iso' CheckTx TxResult

-- | This class is used to set the <a>TxResult</a> data into the
--   appropriate | response fields for the DeliverTx abci-message.
deliverTxTxResult :: Iso' DeliverTx TxResult
instance Data.Default.Class.Default Tendermint.SDK.Types.TxResult.TxResult
instance GHC.Show.Show Tendermint.SDK.Types.TxResult.TxResult

module Tendermint.SDK.BaseApp.Errors

-- | This type represents a common error response for the query, checkTx, |
--   and deliver tx abci-messages.
data AppError
AppError :: Word32 -> Text -> Text -> AppError
[appErrorCode] :: AppError -> Word32
[appErrorCodespace] :: AppError -> Text
[appErrorMessage] :: AppError -> Text

-- | Allows for custom application error types to be coerced into the
--   standard error resposne.
class IsAppError e
makeAppError :: IsAppError e => e -> AppError

-- | This lens is used to set the <a>AppError</a> data into the appropriate
--   | response fields for the query abci-message.
queryAppError :: Lens' Query AppError

-- | This lens is used to set the <a>AppError</a> data into the appropriate
--   | response fields for the checkTx/deliverTx abci-message.
txResultAppError :: Lens' TxResult AppError

-- | These errors originate from the SDK itself. The "sdk" namespace is
--   reserved | for this error type and should not be used in modules or
--   applications.
data SDKError

-- | Something went wrong and we have no idea what.
InternalError :: SDKError

-- | Parsing errors for SDK specific types, e.g. <tt>RawTransaction</tt> or
--   <tt>Msg</tt>, etc.
ParseError :: Text -> SDKError

-- | The name of the route that failed to match.
UnmatchedRoute :: Text -> SDKError
OutOfGasException :: SDKError
MessageValidation :: [Text] -> SDKError
SignatureRecoveryError :: Text -> SDKError
NonceException :: Word64 -> Word64 -> SDKError
RawStoreInvalidOperation :: Text -> SDKError
GrpcError :: Text -> SDKError
UnknownAccountError :: Address -> SDKError

-- | As of right now it's not expected that one can recover from an
--   <a>SDKError</a>, | so we are throwing them as <a>AppError</a>s
--   directly.
throwSDKError :: Member (Error AppError) r => SDKError -> Sem r a
instance GHC.Show.Show Tendermint.SDK.BaseApp.Errors.SDKError
instance GHC.Show.Show Tendermint.SDK.BaseApp.Errors.AppError
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Errors.AppError
instance Tendermint.SDK.BaseApp.Errors.IsAppError Tendermint.SDK.BaseApp.Errors.SDKError
instance GHC.Exception.Type.Exception Tendermint.SDK.BaseApp.Errors.AppError

module Tendermint.SDK.BaseApp.Store.RawStore
type StoreEffs = [Tagged  'Consensus ReadStore, Tagged  'QueryAndMempool ReadStore, Tagged  'Consensus WriteStore, Transaction, CommitBlock]
data ReadStore m a
[StoreGet] :: RawStoreKey -> ReadStore m (Maybe ByteString)
[StoreProve] :: RawStoreKey -> ReadStore m (Maybe ByteString)
get :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Members [ReadStore, Error AppError] r => StoreKey ns -> k -> Sem r (Maybe (Value k ns))
prove :: forall k ns r. IsKey k ns => Member ReadStore r => StoreKey ns -> k -> Sem r (Maybe ByteString)
data WriteStore m a
[StorePut] :: RawStoreKey -> ByteString -> WriteStore m ()
[StoreDelete] :: RawStoreKey -> WriteStore m ()
put :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Member WriteStore r => StoreKey ns -> k -> Value k ns -> Sem r ()
storePut :: forall r_a1cpt. MemberWithError WriteStore r_a1cpt => RawStoreKey -> ByteString -> Sem r_a1cpt ()
delete :: forall k ns r. IsKey k ns => Member WriteStore r => StoreKey ns -> k -> Sem r ()
storeDelete :: forall r_a1cpw. MemberWithError WriteStore r_a1cpw => RawStoreKey -> Sem r_a1cpw ()
data CommitBlock m a
[CommitBlock] :: CommitBlock m Base64String
commitBlock :: forall r_a1cvp. MemberWithError CommitBlock r_a1cvp => Sem r_a1cvp Base64String
data Transaction m a
[BeginTransaction] :: Transaction m ()
[Rollback] :: Transaction m ()
[Commit] :: Transaction m CommitResponse
beginTransaction :: forall r_a1cHs. MemberWithError Transaction r_a1cHs => Sem r_a1cHs ()
withSandbox :: forall r a. Members [Transaction, Resource, Error AppError] r => Sem r a -> Sem r a
withTransaction :: forall r a. Members [Transaction, Resource, Error AppError] r => Sem r a -> Sem r (a, CommitResponse)
commit :: forall r_a1cHu. MemberWithError Transaction r_a1cHu => Sem r_a1cHu CommitResponse
data Scope
Consensus :: Scope
QueryAndMempool :: Scope
data Version
Genesis :: Version
Version :: Natural -> Version
Latest :: Version
class RawKey k
rawKey :: RawKey k => Iso' k ByteString
class RawKey k => IsKey k ns where {
    type family Value k ns = a | a -> ns k;
}
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
data RawStoreKey
RawStoreKey :: ByteString -> ByteString -> RawStoreKey
[rsStoreKey] :: RawStoreKey -> ByteString
[rsKey] :: RawStoreKey -> ByteString
makeRawKey :: RawStoreKey -> ByteString
newtype StoreKey ns
StoreKey :: ByteString -> StoreKey ns
data CommitResponse
CommitResponse :: Base64String -> Natural -> CommitResponse
[rootHash] :: CommitResponse -> Base64String
[newVersion] :: CommitResponse -> Natural
instance GHC.Show.Show Tendermint.SDK.BaseApp.Store.RawStore.Version
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Store.RawStore.Version
instance GHC.Show.Show Tendermint.SDK.BaseApp.Store.RawStore.CommitResponse
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Store.RawStore.CommitResponse
instance Tendermint.SDK.BaseApp.Store.RawStore.RawKey Tendermint.SDK.Types.Address.Address
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Store.RawStore.RawStoreKey
instance GHC.Show.Show Tendermint.SDK.BaseApp.Store.RawStore.RawStoreKey
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Store.RawStore.RawStoreKey

module Tendermint.SDK.BaseApp.Transaction.Cache
data Cache
emptyCache :: Cache
writeCache :: Member (Tagged  'Consensus WriteStore) r => Cache -> Sem r ()
data Deleted
Deleted :: Deleted
put :: RawStoreKey -> ByteString -> Cache -> Cache
get :: RawStoreKey -> Cache -> Either Deleted (Maybe ByteString)
delete :: RawStoreKey -> Cache -> Cache
instance GHC.Show.Show Tendermint.SDK.BaseApp.Transaction.Cache.Cache
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Transaction.Cache.Cache

module Tendermint.SDK.BaseApp.Store.MemoryStore
data DBVersions
DBVersions :: IORef Version -> IORef Version -> DBVersions
[latest] :: DBVersions -> IORef Version
[committed] :: DBVersions -> IORef Version
initDBVersions :: IO DBVersions
data DB
initDB :: IO DB
evalStoreEffs :: Members [Embed IO, Reader DBVersions, Reader DB] r => forall a. Sem (StoreEffs :& r) a -> Sem r a
instance Crypto.Data.Auth.Tree.Class.MerkleHash Tendermint.SDK.BaseApp.Store.MemoryStore.AuthTreeHash

module Tendermint.SDK.BaseApp.Store

module Tendermint.SDK.BaseApp.Store.IAVLStore
data IAVLVersions
IAVLVersions :: IORef Version -> IORef Version -> IAVLVersions
[latest] :: IAVLVersions -> IORef Version
[committed] :: IAVLVersions -> IORef Version
initIAVLVersions :: IO IAVLVersions
evalStoreEffs :: Members [Embed IO, Reader IAVLVersions, Error AppError, Reader GrpcClient] r => forall a. Sem (StoreEffs :& r) a -> Sem r a
data GrpcClient

-- | initGrpcClient
data GrpcConfig
GrpcConfig :: String -> Integer -> GrpcConfig
[grpcHost] :: GrpcConfig -> String
[grpcPort] :: GrpcConfig -> Integer

-- | Initialize the GRPC Client
initGrpcClient :: GrpcConfig -> IO GrpcClient

module Tendermint.SDK.BaseApp.Effects.CoreEffs

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type CoreEffs = '[Reader LogConfig, Reader (Maybe PrometheusEnv), Reader IAVLVersions, Reader GrpcClient, Embed IO]

-- | <a>Context</a> is the environment required to run <a>CoreEffs</a> to
--   <a>IO</a>
data Context
Context :: LogConfig -> Maybe PrometheusEnv -> GrpcClient -> IAVLVersions -> Context
[_contextLogConfig] :: Context -> LogConfig
[_contextPrometheusEnv] :: Context -> Maybe PrometheusEnv
[_contextGrpcClient] :: Context -> GrpcClient
[_contextVersions] :: Context -> IAVLVersions
contextLogConfig :: Lens' Context LogConfig
contextPrometheusEnv :: Lens' Context (Maybe PrometheusEnv)
contextVersions :: Lens' Context IAVLVersions
contextGrpcClient :: Lens' Context GrpcClient
makeContext :: InitialLogNamespace -> Maybe MetricsScrapingConfig -> IAVLVersions -> GrpcConfig -> IO Context

-- | The standard interpeter for <a>CoreEffs</a>.
runCoreEffs :: Context -> forall a. Sem CoreEffs a -> IO a

module Tendermint.SDK.BaseApp.Router.Types
type Application m req res = req -> m (RouteResult res)
data RouterError
PathNotFound :: RouterError
ResourceNotFound :: RouterError
InvalidRequest :: Text -> RouterError
InternalError :: Text -> RouterError
data RouteResult a
Fail :: RouterError -> RouteResult a
FailFatal :: RouterError -> RouteResult a
Route :: a -> RouteResult a
data RouteResultT m a
RouteResultT :: m (RouteResult a) -> RouteResultT m a
[runRouteResultT] :: RouteResultT m a -> m (RouteResult a)
class HasPath t
path :: HasPath t => Lens' t Text
instance GHC.Base.Functor m => GHC.Base.Functor (Tendermint.SDK.BaseApp.Router.Types.RouteResultT m)
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Router.Types.RouteResult
instance GHC.Show.Show Tendermint.SDK.BaseApp.Router.Types.RouterError
instance Control.Monad.Trans.Class.MonadTrans Tendermint.SDK.BaseApp.Router.Types.RouteResultT
instance GHC.Base.Monad m => GHC.Base.Applicative (Tendermint.SDK.BaseApp.Router.Types.RouteResultT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Tendermint.SDK.BaseApp.Router.Types.RouteResultT m)
instance GHC.Base.Applicative Tendermint.SDK.BaseApp.Router.Types.RouteResult
instance GHC.Base.Monad Tendermint.SDK.BaseApp.Router.Types.RouteResult
instance Tendermint.SDK.BaseApp.Errors.IsAppError Tendermint.SDK.BaseApp.Router.Types.RouterError

module Tendermint.SDK.BaseApp.Router.Router
type Router env r req res = Router' env (Application (Sem r) req res)
data Router' env a
StaticRouter :: Map Text (Router' env a) -> [env -> a] -> Router' env a
CaptureRouter :: Router' (Text, env) a -> Router' env a
Choice :: Router' env a -> Router' env a -> Router' env a
runRouter :: HasPath req => Router env r req res -> env -> Application (Sem r) req res
pathRouter :: Text -> Router' env a -> Router' env a
leafRouter :: (env -> a) -> Router' env a
choice :: Router' env a -> Router' env a -> Router' env a

module Tendermint.SDK.BaseApp.Router.Delayed
data Delayed m env req a
runAction :: Delayed (Sem r) env req (Sem r a) -> env -> req -> (a -> Sem r (RouteResult b)) -> Sem r (RouteResult b)

-- | Fail with the option to recover.
delayedFail :: Monad m => RouterError -> DelayedM m req a
addBody :: Monad m => Delayed m env req (a -> b) -> DelayedM m req a -> Delayed m env req b
addCapture :: Monad m => Delayed m env req (a -> b) -> (captured -> DelayedM m req a) -> Delayed m (captured, env) req b
addParameter :: Monad m => Delayed m env req (a -> b) -> DelayedM m req a -> Delayed m env req b
emptyDelayed :: Monad m => RouteResult a -> Delayed m b req a

-- | Gain access to the incoming request.
withRequest :: Monad m => (req -> DelayedM m req a) -> DelayedM m req a
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader req (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Monad m => GHC.Base.Monad (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Monad m => GHC.Base.Applicative (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Functor m => GHC.Base.Functor (Tendermint.SDK.BaseApp.Router.Delayed.DelayedM m req)
instance GHC.Base.Functor m => GHC.Base.Functor (Tendermint.SDK.BaseApp.Router.Delayed.Delayed m env req)

module Tendermint.SDK.BaseApp.Query.Types
data Leaf (a :: *)
data QA (a :: *)
data EmptyQueryServer
EmptyQueryServer :: EmptyQueryServer

-- | This class is used to parse the 'data' field of the query request
--   message. | The default method assumes that the 'data' is simply the
--   key for the | value being queried.
class FromQueryData a
fromQueryData :: FromQueryData a => Base64String -> Either String a
fromQueryData :: (FromQueryData a, RawKey a) => Base64String -> Either String a
type QueryApplication m = Query -> m Query
data QueryRequest
QueryRequest :: Text -> Text -> Base64String -> Bool -> Int64 -> QueryRequest
[queryRequestPath] :: QueryRequest -> Text
[queryRequestParamString] :: QueryRequest -> Text
[queryRequestData] :: QueryRequest -> Base64String
[queryRequestProve] :: QueryRequest -> Bool
[queryRequestHeight] :: QueryRequest -> Int64
parseQueryRequest :: Query -> QueryRequest
data QueryArgs a
QueryArgs :: Bool -> a -> Int64 -> QueryArgs a
[queryArgsProve] :: QueryArgs a -> Bool
[queryArgsData] :: QueryArgs a -> a
[queryArgsHeight] :: QueryArgs a -> Int64
defaultQueryArgs :: QueryArgs ()
data QueryResult a
QueryResult :: a -> Int64 -> Base64String -> Maybe Proof -> Int64 -> QueryResult a
[queryResultData] :: QueryResult a -> a
[queryResultIndex] :: QueryResult a -> Int64
[queryResultKey] :: QueryResult a -> Base64String
[queryResultProof] :: QueryResult a -> Maybe Proof
[queryResultHeight] :: QueryResult a -> Int64

-- | class representing objects which can be queried via the hs-abci query
--   message. | Here the <a>Name</a> is the leaf of the query url, e.g. if
--   you can access a token | balance of type <tt>Balance</tt> at
--   "token/balance", then 'Name Balance ~ "balance"'.
class HasCodec a => Queryable a where {
    type family Name a :: Symbol;
}
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Query.Types.QueryResult
instance GHC.Show.Show a => GHC.Show.Show (Tendermint.SDK.BaseApp.Query.Types.QueryResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Tendermint.SDK.BaseApp.Query.Types.QueryResult a)
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Query.Types.QueryArgs
instance GHC.Show.Show Tendermint.SDK.BaseApp.Query.Types.QueryRequest
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Query.Types.QueryRequest
instance Tendermint.SDK.BaseApp.Query.Types.FromQueryData Tendermint.SDK.Types.Address.Address
instance Tendermint.SDK.BaseApp.Router.Types.HasPath Tendermint.SDK.BaseApp.Query.Types.QueryRequest

module Tendermint.SDK.BaseApp.Query.Router

-- | This class is used to construct a router given a <tt>layout</tt> type.
--   The layout | is constructed using the combinators that appear in the
--   instances here, no other | Servant combinators are recognized.
class HasQueryRouter layout r where {
    
    -- | A routeQ handler.
    type family RouteQ layout r :: *;
}

-- | Transform a routeQ handler into a <tt>Router</tt>.
routeQ :: HasQueryRouter layout r => Proxy layout -> Proxy r -> Delayed (Sem r) env QueryRequest (RouteQ layout (QueryEffs :& r)) -> Router env r QueryRequest Query
hoistQueryRouter :: HasQueryRouter layout r => Proxy layout -> Proxy r -> (forall a. Sem s a -> Sem s' a) -> RouteQ layout s -> RouteQ layout s'
methodRouter :: HasCodec a => Member (Tagged  'QueryAndMempool ReadStore) r => Delayed (Sem r) env req (Sem (QueryEffs :& r) (QueryResult a)) -> Router env r req Query
instance (Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter a r, Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter b r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (a Servant.API.Alternative.:<|> b) r
instance (Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r, GHC.TypeLits.KnownSymbol path) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (path Servant.API.Sub.:> sublayout) r
instance (Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r, GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods), Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldLenient mods)) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> sublayout) r
instance (Web.Internal.HttpApiData.FromHttpApiData a, Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Servant.API.Capture.Capture' mods capture a Servant.API.Sub.:> sublayout) r
instance (Tendermint.SDK.BaseApp.Query.Types.FromQueryData a, Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter sublayout r) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Types.QA a Servant.API.Sub.:> sublayout) r
instance (Polysemy.Internal.Union.Member (Polysemy.Tagged.Tagged 'Tendermint.SDK.BaseApp.Store.RawStore.QueryAndMempool Tendermint.SDK.BaseApp.Store.RawStore.ReadStore) r, Tendermint.SDK.Codec.HasCodec a) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Types.Leaf a) r
instance Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter Tendermint.SDK.BaseApp.Query.Types.EmptyQueryServer r

module Tendermint.SDK.BaseApp.Query.Store
data StoreLeaf a
class StoreQueryHandlers (kvs :: [*]) (ns :: Symbol) r where {
    type family QueryApi kvs :: *;
}
storeQueryHandlers :: StoreQueryHandlers kvs ns r => Proxy kvs -> StoreKey ns -> Proxy r -> RouteQ (QueryApi kvs) r
instance (Tendermint.SDK.BaseApp.Store.RawStore.IsKey k ns, a Data.Type.Equality.~ Tendermint.SDK.BaseApp.Store.RawStore.Value k ns, Tendermint.SDK.Codec.HasCodec a, Polysemy.Internal.Members Tendermint.SDK.BaseApp.Query.Effect.QueryEffs r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandlers '[(k, a)] ns r
instance (Tendermint.SDK.BaseApp.Store.RawStore.IsKey k ns, a Data.Type.Equality.~ Tendermint.SDK.BaseApp.Store.RawStore.Value k ns, Tendermint.SDK.Codec.HasCodec a, Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandlers ((k', a') : as) ns r, Polysemy.Internal.Members Tendermint.SDK.BaseApp.Query.Effect.QueryEffs r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandlers ((k, a) : (k', a') : as) ns r
instance (Tendermint.SDK.BaseApp.Store.RawStore.IsKey k ns, a Data.Type.Equality.~ Tendermint.SDK.BaseApp.Store.RawStore.Value k ns, Tendermint.SDK.Codec.HasCodec a, Polysemy.Internal.Members Tendermint.SDK.BaseApp.Query.Effect.QueryEffs r) => Tendermint.SDK.BaseApp.Query.Store.StoreQueryHandler a ns (Tendermint.SDK.BaseApp.Query.Types.QueryArgs k -> Polysemy.Internal.Sem r (Tendermint.SDK.BaseApp.Query.Types.QueryResult a))
instance (Tendermint.SDK.BaseApp.Query.Types.Queryable a, Polysemy.Internal.Union.Member (Polysemy.Tagged.Tagged 'Tendermint.SDK.BaseApp.Store.RawStore.QueryAndMempool Tendermint.SDK.BaseApp.Store.RawStore.ReadStore) r, GHC.TypeLits.KnownSymbol (Tendermint.SDK.BaseApp.Query.Types.Name a)) => Tendermint.SDK.BaseApp.Query.Router.HasQueryRouter (Tendermint.SDK.BaseApp.Query.Store.StoreLeaf a) r

module Tendermint.SDK.BaseApp.Query
serveQueryApplication :: HasQueryRouter layout r => Proxy layout -> Proxy r -> RouteQ layout (QueryEffs :& r) -> QueryApplication (Sem r)

-- | This class is used to construct a router given a <tt>layout</tt> type.
--   The layout | is constructed using the combinators that appear in the
--   instances here, no other | Servant combinators are recognized.
class HasQueryRouter layout r where {
    
    -- | A routeQ handler.
    type family RouteQ layout r :: *;
}

-- | Transform a routeQ handler into a <tt>Router</tt>.
routeQ :: HasQueryRouter layout r => Proxy layout -> Proxy r -> Delayed (Sem r) env QueryRequest (RouteQ layout (QueryEffs :& r)) -> Router env r QueryRequest Query
hoistQueryRouter :: HasQueryRouter layout r => Proxy layout -> Proxy r -> (forall a. Sem s a -> Sem s' a) -> RouteQ layout s -> RouteQ layout s'
class StoreQueryHandlers (kvs :: [*]) (ns :: Symbol) r where {
    type family QueryApi kvs :: *;
}
storeQueryHandlers :: StoreQueryHandlers kvs ns r => Proxy kvs -> StoreKey ns -> Proxy r -> RouteQ (QueryApi kvs) r
type QueryEffs = '[ReadStore, Error AppError]

module Tendermint.SDK.BaseApp.Gas
data GasMeter m a
[WithGas] :: forall m a. GasAmount -> m a -> GasMeter m a
newtype GasAmount
GasAmount :: Int64 -> GasAmount
[unGasAmount] :: GasAmount -> Int64
withGas :: forall r_a1y4M a_a1xUh. MemberWithError GasMeter r_a1y4M => GasAmount -> Sem r_a1y4M a_a1xUh -> Sem r_a1y4M a_a1xUh
eval :: Members [Error AppError, State GasAmount] r => Sem (GasMeter : r) a -> Sem r a
doNothing :: forall r. forall a. Sem (GasMeter : r) a -> Sem r a
instance GHC.Classes.Ord Tendermint.SDK.BaseApp.Gas.GasAmount
instance GHC.Num.Num Tendermint.SDK.BaseApp.Gas.GasAmount
instance GHC.Show.Show Tendermint.SDK.BaseApp.Gas.GasAmount
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Gas.GasAmount

module Tendermint.SDK.BaseApp.Transaction.Types
type TransactionApplication m = RoutingTx ByteString -> m (TxResult, Maybe Cache)
data TransactionContext
TransactionContext :: IORef GasAmount -> IORef Cache -> IORef [Event] -> TransactionContext
[gasRemaining] :: TransactionContext -> IORef GasAmount
[storeCache] :: TransactionContext -> IORef Cache
[events] :: TransactionContext -> IORef [Event]
data RoutingTx msg
[RoutingTx] :: Tx alg msg -> RoutingTx msg
data RouteContext
CheckTx :: RouteContext
DeliverTx :: RouteContext
data EmptyTxServer
EmptyTxServer :: EmptyTxServer
data Return a
data TypedMessage msg
data msg :~> a
newTransactionContext :: RoutingTx msg -> IO TransactionContext
data Tx alg msg
Tx :: Msg msg -> Text -> Int64 -> RecoverableSignature alg -> Message alg -> PubKey alg -> Word64 -> Tx alg msg
[txMsg] :: Tx alg msg -> Msg msg
[txRoute] :: Tx alg msg -> Text
[txGas] :: Tx alg msg -> Int64
[txSignature] :: Tx alg msg -> RecoverableSignature alg
[txSignBytes] :: Tx alg msg -> Message alg
[txSigner] :: Tx alg msg -> PubKey alg
[txNonce] :: Tx alg msg -> Word64
instance GHC.Show.Show Tendermint.SDK.BaseApp.Transaction.Types.RouteContext
instance GHC.Classes.Eq Tendermint.SDK.BaseApp.Transaction.Types.RouteContext
instance GHC.Base.Functor Tendermint.SDK.BaseApp.Transaction.Types.RoutingTx
instance Tendermint.SDK.BaseApp.Router.Types.HasPath (Tendermint.SDK.BaseApp.Transaction.Types.RoutingTx msg)

module Tendermint.SDK.BaseApp.Transaction.Checker
class DefaultCheckTx api (r :: EffectRow) where {
    type family DefaultCheckTxT api r :: *;
}
defaultCheckTx :: DefaultCheckTx api r => Proxy api -> Proxy r -> DefaultCheckTxT api r
type family VoidReturn (api :: *) :: *
instance (Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx a r, Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx b r) => Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx (a Servant.API.Alternative.:<|> b) r
instance forall k rest (r :: Polysemy.Internal.Kind.EffectRow) (path :: k). Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx rest r => Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx (path Servant.API.Sub.:> rest) r
instance forall k (r :: [(* -> *) -> * -> *]) msg (a :: k). (Polysemy.Internal.Union.Member (Polysemy.Error.Error Tendermint.SDK.BaseApp.Errors.AppError) r, Tendermint.SDK.Types.Message.ValidateMessage msg) => Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx (Tendermint.SDK.BaseApp.Transaction.Types.TypedMessage msg Tendermint.SDK.BaseApp.Transaction.Types.:~> Tendermint.SDK.BaseApp.Transaction.Types.Return a) r
instance Tendermint.SDK.BaseApp.Transaction.Checker.DefaultCheckTx Tendermint.SDK.BaseApp.Transaction.Types.EmptyTxServer r

module Tendermint.SDK.BaseApp.Transaction.AnteHandler
type AnteHandler r = forall msg a. (Endo (RoutingTx msg -> Sem r a))

module Tendermint.SDK.BaseApp.Transaction.Effect
type TxEffs = [Output Event, GasMeter, WriteStore, ReadStore, Error AppError]
runTx :: Members [Embed IO, Tagged scope ReadStore] r => HasCodec a => Proxy scope -> TransactionContext -> Sem (TxEffs :& r) a -> Sem r (TxResult, Maybe Cache)
eval :: forall r scope a. Members [Embed IO, Tagged scope ReadStore] r => Proxy scope -> TransactionContext -> Sem (TxEffs :& r) a -> Sem r (Either AppError a)
evalReadOnly :: forall r. forall a. Sem (TxEffs :& r) a -> Sem (ReadStore : (Error AppError : r)) a

module Tendermint.SDK.BaseApp.Transaction.Router
class HasTxRouter layout (r :: EffectRow) (scope :: Scope) where {
    type family RouteTx layout (s :: EffectRow) :: *;
}
routeTx :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> Delayed (Sem r) env (RoutingTx ByteString) (RouteTx layout (TxEffs :& r)) -> Router env r (RoutingTx ByteString) (TxResult, Maybe Cache)
applyAnteHandler :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> AnteHandler r -> RouteTx layout r -> RouteTx layout r
hoistTxRouter :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> (forall a. Sem s a -> Sem s' a) -> RouteTx layout s -> RouteTx layout s'
emptyTxServer :: RouteTx EmptyTxServer r
instance (Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter a r scope, Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter b r scope) => Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter (a Servant.API.Alternative.:<|> b) r scope
instance (Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter sublayout r scope, GHC.TypeLits.KnownSymbol path) => Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter (path Servant.API.Sub.:> sublayout) r scope
instance (Tendermint.SDK.Types.Message.HasMessageType msg, Tendermint.SDK.Codec.HasCodec msg, Polysemy.Internal.Members '[Polysemy.Tagged.Tagged scope Tendermint.SDK.BaseApp.Store.RawStore.ReadStore, Polysemy.Embed.Type.Embed GHC.Types.IO] r, Tendermint.SDK.Codec.HasCodec a) => Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter (Tendermint.SDK.BaseApp.Transaction.Types.TypedMessage msg Tendermint.SDK.BaseApp.Transaction.Types.:~> Tendermint.SDK.BaseApp.Transaction.Types.Return a) r scope
instance Tendermint.SDK.BaseApp.Transaction.Router.HasTxRouter Tendermint.SDK.BaseApp.Transaction.Types.EmptyTxServer r scope

module Tendermint.SDK.BaseApp.Transaction
serveTxApplication :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> RouteTx layout (TxEffs :& r) -> TransactionApplication (Sem r)
class HasTxRouter layout (r :: EffectRow) (scope :: Scope) where {
    type family RouteTx layout (s :: EffectRow) :: *;
}
routeTx :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> Delayed (Sem r) env (RoutingTx ByteString) (RouteTx layout (TxEffs :& r)) -> Router env r (RoutingTx ByteString) (TxResult, Maybe Cache)
applyAnteHandler :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> AnteHandler r -> RouteTx layout r -> RouteTx layout r
hoistTxRouter :: HasTxRouter layout r scope => Proxy layout -> Proxy r -> Proxy scope -> (forall a. Sem s a -> Sem s' a) -> RouteTx layout s -> RouteTx layout s'
emptyTxServer :: RouteTx EmptyTxServer r
class DefaultCheckTx api (r :: EffectRow) where {
    type family DefaultCheckTxT api r :: *;
}
defaultCheckTx :: DefaultCheckTx api r => Proxy api -> Proxy r -> DefaultCheckTxT api r
type family VoidReturn (api :: *) :: *
type TxEffs = [Output Event, GasMeter, WriteStore, ReadStore, Error AppError]
evalReadOnly :: forall r. forall a. Sem (TxEffs :& r) a -> Sem (ReadStore : (Error AppError : r)) a
type AnteHandler r = forall msg a. (Endo (RoutingTx msg -> Sem r a))

module Tendermint.SDK.BaseApp.Effects.PureCoreEffs

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type PureCoreEffs = '[Reader LogConfig, Reader DBVersions, Reader DB, Error AppError, Embed IO]

-- | <tt>Context</tt> is the environment required to run
--   <tt>CoreEffsPure</tt> to <a>IO</a>
data PureContext
PureContext :: LogConfig -> DB -> DBVersions -> PureContext
[_pureContextLogConfig] :: PureContext -> LogConfig
[_pureContextDB] :: PureContext -> DB
[_pureContextVersions] :: PureContext -> DBVersions
pureContextLogConfig :: Lens' PureContext LogConfig
pureContextVersions :: Lens' PureContext DBVersions
pureContextDB :: Lens' PureContext DB
makePureContext :: InitialLogNamespace -> IO PureContext

-- | The standard interpeter for <a>PureCoreEffs</a>.
runPureCoreEffs :: PureContext -> forall a. Sem PureCoreEffs a -> IO (Either AppError a)

module Tendermint.SDK.BaseApp.Effects.BaseEffs

-- | Concrete row of effects for the BaseApp. Note that because there does
--   | not exist an interpreter for an untagged <tt>RawStore</tt>, you must
--   scope | these effects before they can be interpreted.
type BaseEffs = [Metrics, Logger, Resource, Error AppError]

-- | An intermediary interpeter, bringing <tt>BaseApp</tt> down to
--   <tt>CoreEff</tt>.
evalBaseEffs :: Members [Embed IO, Reader LogConfig, Reader (Maybe PrometheusEnv)] core => forall a. Sem (BaseEffs :& core) a -> Sem core a
evalBaseEffsPure :: Members [Embed IO, Reader LogConfig] core => forall a. Sem (BaseEffs :& core) a -> Sem core a

module Tendermint.SDK.BaseApp.Effects
type BaseAppEffs core = StoreEffs :& BaseEffs :& core
defaultCompileToCore :: forall a. Sem (BaseAppEffs CoreEffs) a -> Sem CoreEffs a
defaultCompileToPureCore :: forall a. Sem (BaseAppEffs PureCoreEffs) a -> Sem PureCoreEffs a

module Tendermint.SDK.BaseApp

-- | Concrete row of effects for the BaseApp. Note that because there does
--   | not exist an interpreter for an untagged <tt>RawStore</tt>, you must
--   scope | these effects before they can be interpreted.
type BaseEffs = [Metrics, Logger, Resource, Error AppError]
defaultCompileToCore :: forall a. Sem (BaseAppEffs CoreEffs) a -> Sem CoreEffs a
defaultCompileToPureCore :: forall a. Sem (BaseAppEffs PureCoreEffs) a -> Sem PureCoreEffs a
type BaseAppEffs core = StoreEffs :& BaseEffs :& core

-- | This type family gives a nice syntax for combining multiple lists of
--   effects.
type family (as :: [a]) :& (bs :: [a]) :: [a]
infixr 5 :&

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type CoreEffs = '[Reader LogConfig, Reader (Maybe PrometheusEnv), Reader IAVLVersions, Reader GrpcClient, Embed IO]

-- | <a>Context</a> is the environment required to run <a>CoreEffs</a> to
--   <a>IO</a>
data Context
Context :: LogConfig -> Maybe PrometheusEnv -> GrpcClient -> IAVLVersions -> Context
[_contextLogConfig] :: Context -> LogConfig
[_contextPrometheusEnv] :: Context -> Maybe PrometheusEnv
[_contextGrpcClient] :: Context -> GrpcClient
[_contextVersions] :: Context -> IAVLVersions
contextLogConfig :: Lens' Context LogConfig
contextPrometheusEnv :: Lens' Context (Maybe PrometheusEnv)
contextVersions :: Lens' Context IAVLVersions
makeContext :: InitialLogNamespace -> Maybe MetricsScrapingConfig -> IAVLVersions -> GrpcConfig -> IO Context

-- | The standard interpeter for <a>CoreEffs</a>.
runCoreEffs :: Context -> forall a. Sem CoreEffs a -> IO a

-- | CoreEffs is one level below BaseAppEffs, and provides one possible |
--   interpretation for its effects to IO.
type PureCoreEffs = '[Reader LogConfig, Reader DBVersions, Reader DB, Error AppError, Embed IO]

-- | <tt>Context</tt> is the environment required to run
--   <tt>CoreEffsPure</tt> to <a>IO</a>
data PureContext
PureContext :: LogConfig -> DB -> DBVersions -> PureContext
[_pureContextLogConfig] :: PureContext -> LogConfig
[_pureContextDB] :: PureContext -> DB
[_pureContextVersions] :: PureContext -> DBVersions
pureContextLogConfig :: Lens' PureContext LogConfig
pureContextVersions :: Lens' PureContext DBVersions
pureContextDB :: Lens' PureContext DB
makePureContext :: InitialLogNamespace -> IO PureContext

-- | The standard interpeter for <a>PureCoreEffs</a>.
runPureCoreEffs :: PureContext -> forall a. Sem PureCoreEffs a -> IO (Either AppError a)
data ReadStore m a
data WriteStore m a
class RawKey k
rawKey :: RawKey k => Iso' k ByteString
class RawKey k => IsKey k ns where {
    type family Value k ns = a | a -> ns k;
}
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
prefix :: IsKey k ns => Proxy k -> Proxy ns -> ByteString
newtype StoreKey ns
StoreKey :: ByteString -> StoreKey ns
put :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Member WriteStore r => StoreKey ns -> k -> Value k ns -> Sem r ()
get :: forall k r ns. IsKey k ns => HasCodec (Value k ns) => Members [ReadStore, Error AppError] r => StoreKey ns -> k -> Sem r (Maybe (Value k ns))
delete :: forall k ns r. IsKey k ns => Member WriteStore r => StoreKey ns -> k -> Sem r ()
data Leaf (a :: *)
data QA (a :: *)

-- | This type represents a common error response for the query, checkTx, |
--   and deliver tx abci-messages.
data AppError
AppError :: Word32 -> Text -> Text -> AppError
[appErrorCode] :: AppError -> Word32
[appErrorCodespace] :: AppError -> Text
[appErrorMessage] :: AppError -> Text

-- | Allows for custom application error types to be coerced into the
--   standard error resposne.
class IsAppError e
makeAppError :: IsAppError e => e -> AppError
data Event
Event :: Text -> [KVPair] -> Event

-- | Type of Event
[eventType] :: Event -> Text

-- | Event attributes
[eventAttributes] :: Event -> [KVPair]

-- | A class representing a type that can be emitted as an event in the |
--   event logs for the deliverTx response.
class ToEvent e
makeEventType :: ToEvent e => Proxy e -> String
makeEventData :: ToEvent e => e -> [(ByteString, ByteString)]
makeEventData :: (ToEvent e, ToJSON e) => e -> [(ByteString, ByteString)]

-- | Special event wrapper to add contextual event_type info
newtype ContextEvent t
ContextEvent :: t -> ContextEvent t
emit :: ToEvent e => Member (Output Event) r => e -> Sem r ()
logEvent :: forall e r. (ToJSON e, ToEvent e, Select e) => Member Logger r => e -> Sem r ()
data GasMeter m a
withGas :: forall r_a1y4M a_a1xUh. MemberWithError GasMeter r_a1y4M => GasAmount -> Sem r_a1y4M a_a1xUh -> Sem r_a1y4M a_a1xUh

-- | Effect allowing for console logging.
data Logger m a
log :: forall r_aCqy. MemberWithError Logger r_aCqy => Severity -> Text -> Sem r_aCqy ()
data LogSelect
All :: LogSelect
Some :: [Text] -> LogSelect
addContext :: forall r_aCqB x_XB4x a_aB4y. (MemberWithError Logger r_aCqB, Select x_XB4x, ToJSON x_XB4x) => x_XB4x -> Sem r_aCqB a_aB4y -> Sem r_aCqB a_aB4y
data Severity
Debug :: Severity
Info :: Severity
Warning :: Severity
Error :: Severity
Exception :: Severity

-- | Class for selecting object keys for contextual logging
class Select a
select :: Select a => Verbosity -> a -> LogSelect
select :: Select a => Verbosity -> a -> LogSelect
data Verbosity
V0 :: Verbosity
V1 :: Verbosity
V2 :: Verbosity
V3 :: Verbosity
data Metrics m a
incCount :: forall r_aQSH. MemberWithError Metrics r_aQSH => CountName -> Sem r_aQSH ()
withTimer :: forall r_aQSJ a_aQHF. MemberWithError Metrics r_aQSJ => HistogramName -> Sem r_aQSJ a_aQHF -> Sem r_aQSJ a_aQHF
data CountName
CountName :: Text -> [(Text, Text)] -> CountName
[countName] :: CountName -> Text
[countLabels] :: CountName -> [(Text, Text)]
data HistogramName
HistogramName :: Text -> [(Text, Text)] -> [Double] -> HistogramName
[histogramName] :: HistogramName -> Text
[histogramLabels] :: HistogramName -> [(Text, Text)]
[histogramBuckets] :: HistogramName -> [Double]
type AnteHandler r = forall msg a. (Endo (RoutingTx msg -> Sem r a))
data RoutingTx msg
[RoutingTx] :: Tx alg msg -> RoutingTx msg
type family RouteTx layout (s :: EffectRow) :: *
data RouteContext
CheckTx :: RouteContext
DeliverTx :: RouteContext
data Return a
data msg :~> a
data TypedMessage msg
type TxEffs = [Output Event, GasMeter, WriteStore, ReadStore, Error AppError]
data EmptyTxServer
EmptyTxServer :: EmptyTxServer
class DefaultCheckTx api (r :: EffectRow) where {
    type family DefaultCheckTxT api r :: *;
}
defaultCheckTx :: DefaultCheckTx api r => Proxy api -> Proxy r -> DefaultCheckTxT api r
type family VoidReturn (api :: *) :: *
type QueryEffs = '[ReadStore, Error AppError]

-- | class representing objects which can be queried via the hs-abci query
--   message. | Here the <a>Name</a> is the leaf of the query url, e.g. if
--   you can access a token | balance of type <tt>Balance</tt> at
--   "token/balance", then 'Name Balance ~ "balance"'.
class HasCodec a => Queryable a where {
    type family Name a :: Symbol;
}

-- | This class is used to parse the 'data' field of the query request
--   message. | The default method assumes that the 'data' is simply the
--   key for the | value being queried.
class FromQueryData a
fromQueryData :: FromQueryData a => Base64String -> Either String a
fromQueryData :: (FromQueryData a, RawKey a) => Base64String -> Either String a

-- | A routeQ handler.
type family RouteQ layout r :: *
type family QueryApi kvs :: *
data QueryResult a
QueryResult :: a -> Int64 -> Base64String -> Maybe Proof -> Int64 -> QueryResult a
[queryResultData] :: QueryResult a -> a
[queryResultIndex] :: QueryResult a -> Int64
[queryResultKey] :: QueryResult a -> Base64String
[queryResultProof] :: QueryResult a -> Maybe Proof
[queryResultHeight] :: QueryResult a -> Int64
storeQueryHandlers :: StoreQueryHandlers kvs ns r => Proxy kvs -> StoreKey ns -> Proxy r -> RouteQ (QueryApi kvs) r
data EmptyQueryServer
EmptyQueryServer :: EmptyQueryServer
data RouterError
ResourceNotFound :: RouterError

module Tendermint.SDK.Application.Module
data Module (name :: Symbol) (check :: *) (deliver :: *) (query :: *) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow)
Module :: RouteTx check r -> RouteTx deliver r -> RouteQ query r -> (forall s. (Members TxEffs s, Members (DependencyEffs deps) s) => forall a. Sem (es :& s) a -> Sem s a) -> Module
[moduleTxChecker] :: Module -> RouteTx check r
[moduleTxDeliverer] :: Module -> RouteTx deliver r
[moduleQuerier] :: Module -> RouteQ query r
[moduleEval] :: Module -> forall s. (Members TxEffs s, Members (DependencyEffs deps) s) => forall a. Sem (es :& s) a -> Sem s a
type Component = EffectRow -> Type
type family ModuleEffs (m :: Component) :: EffectRow
data ModuleList (ms :: [Component]) r
[NilModules] :: ModuleList '[] r
[:+] :: Module name check deliver query es deps r -> ModuleList ms r -> ModuleList (Module name check deliver query es deps : ms) r
infixr 5 :+
data Application check deliver query r s
Application :: RouteTx check r -> RouteTx deliver r -> RouteQ query s -> Application check deliver query r s
[applicationTxChecker] :: Application check deliver query r s -> RouteTx check r
[applicationTxDeliverer] :: Application check deliver query r s -> RouteTx deliver r
[applicationQuerier] :: Application check deliver query r s -> RouteQ query s
class ToApplication ms r where {
    type family ApplicationC ms :: *;
    type family ApplicationD ms :: *;
    type family ApplicationQ ms :: *;
}
toApplication :: ToApplication ms r => ModuleList ms r -> Application (ApplicationC ms) (ApplicationD ms) (ApplicationQ ms) r r
hoistApplication :: HasTxRouter check r  'QueryAndMempool => HasTxRouter deliver r  'Consensus => HasQueryRouter query s => (forall a. Sem r a -> Sem r' a) -> (forall a. Sem s a -> Sem s' a) -> Application check deliver query r s -> Application check deliver query r' s'
class Eval ms (core :: EffectRow) where {
    type family Effs ms core :: EffectRow;
}
eval :: Eval ms core => proxy core -> ModuleList ms r -> forall a. Sem (Effs ms core) a -> Sem (TxEffs :& BaseAppEffs core) a
makeApplication :: Eval ms core => ToApplication ms (Effs ms core) => HasTxRouter (ApplicationC ms) (Effs ms core)  'QueryAndMempool => HasTxRouter (ApplicationD ms) (Effs ms core)  'Consensus => HasQueryRouter (ApplicationQ ms) (Effs ms core) => Proxy core -> AnteHandler (Effs ms core) -> ModuleList ms (Effs ms core) -> Application (ApplicationC ms) (ApplicationD ms) (ApplicationQ ms) (TxEffs :& BaseAppEffs core) (QueryEffs :& BaseAppEffs core)
applyAnteHandler :: HasTxRouter check r  'QueryAndMempool => HasTxRouter deliver r  'Consensus => AnteHandler r -> Application check deliver query r s -> Application check deliver query r s
instance (Tendermint.SDK.Application.Module.DependencyEffs deps Data.Type.Equality.~ '[]) => Tendermint.SDK.Application.Module.Eval '[Tendermint.SDK.Application.Module.Module name check deliver query es deps] core
instance (Polysemy.Internal.Members (Tendermint.SDK.Application.Module.DependencyEffs deps) (Tendermint.SDK.Application.Module.Effs (m' : ms) s), Polysemy.Internal.Members Tendermint.SDK.BaseApp.Transaction.Effect.TxEffs (Tendermint.SDK.Application.Module.Effs (m' : ms) s), Tendermint.SDK.Application.Module.Eval (m' : ms) s) => Tendermint.SDK.Application.Module.Eval (Tendermint.SDK.Application.Module.Module name check deliver query es deps : m' : ms) s
instance Tendermint.SDK.Application.Module.ToApplication '[Tendermint.SDK.Application.Module.Module name check deliver query es deps] r
instance Tendermint.SDK.Application.Module.ToApplication (m' : ms) r => Tendermint.SDK.Application.Module.ToApplication (Tendermint.SDK.Application.Module.Module name check deliver query es deps : m' : ms) r

module Tendermint.SDK.Modules.Auth
type Auth = Module AuthName EmptyTxServer EmptyTxServer Api AuthEffs '[]
authModule :: Members (ModuleEffs Auth) r => Auth r
data Accounts m a
[PutAccount] :: Address -> Account -> Accounts m ()
[GetAccount] :: Address -> Accounts m (Maybe Account)
type AuthEffs = '[Accounts, Error AuthError]
putAccount :: forall r_a1IjK. MemberWithError Accounts r_a1IjK => Address -> Account -> Sem r_a1IjK ()
getAccount :: forall r_a1IjN. MemberWithError Accounts r_a1IjN => Address -> Sem r_a1IjN (Maybe Account)
eval :: Members [ReadStore, WriteStore, Error AppError] r => Sem (Accounts : (Error AuthError : r)) a -> Sem r a
createAccount :: Members [Accounts, Error AuthError] r => Address -> Sem r Account
type Api = QueryApi AuthContents
querier :: Members QueryEffs r => RouteQ Api r
type AuthName = "auth"
data AuthError
AccountAlreadyExists :: Address -> AuthError
newtype CoinId
CoinId :: Text -> CoinId
[unCoinId] :: CoinId -> Text
newtype Amount
Amount :: Word64 -> Amount
[unAmount] :: Amount -> Word64
data Coin
Coin :: CoinId -> Amount -> Coin
[coinId] :: Coin -> CoinId
[coinAmount] :: Coin -> Amount
coinAesonOptions :: Options
data Account
Account :: [Coin] -> Word64 -> Account
[accountCoins] :: Account -> [Coin]
[accountNonce] :: Account -> Word64

module Tendermint.SDK.Modules.Bank.Types
type BankName = "bank"
data BankError
InsufficientFunds :: Text -> BankError
data TransferEvent
TransferEvent :: CoinId -> Amount -> Address -> Address -> TransferEvent
[transferEventCoinId] :: TransferEvent -> CoinId
[transferEventAmount] :: TransferEvent -> Amount
[transferEventTo] :: TransferEvent -> Address
[transferEventFrom] :: TransferEvent -> Address
transferEventAesonOptions :: Options
instance GHC.Generics.Generic Tendermint.SDK.Modules.Bank.Types.TransferEvent
instance GHC.Show.Show Tendermint.SDK.Modules.Bank.Types.TransferEvent
instance GHC.Classes.Eq Tendermint.SDK.Modules.Bank.Types.TransferEvent
instance Data.Aeson.Types.ToJSON.ToJSON Tendermint.SDK.Modules.Bank.Types.TransferEvent
instance Data.Aeson.Types.FromJSON.FromJSON Tendermint.SDK.Modules.Bank.Types.TransferEvent
instance Tendermint.SDK.BaseApp.Events.ToEvent Tendermint.SDK.Modules.Bank.Types.TransferEvent
instance Tendermint.SDK.BaseApp.Logger.Select Tendermint.SDK.Modules.Bank.Types.TransferEvent
instance Tendermint.SDK.BaseApp.Errors.IsAppError Tendermint.SDK.Modules.Bank.Types.BankError

module Tendermint.SDK.Modules.Bank.Messages
data Transfer
Transfer :: Address -> Address -> CoinId -> Amount -> Transfer
[transferTo] :: Transfer -> Address
[transferFrom] :: Transfer -> Address
[transferCoinId] :: Transfer -> CoinId
[transferAmount] :: Transfer -> Amount
data Burn
Burn :: Address -> CoinId -> Amount -> Burn
[burnAddress] :: Burn -> Address
[burnCoinId] :: Burn -> CoinId
[burnAmount] :: Burn -> Amount
instance GHC.Generics.Generic Tendermint.SDK.Modules.Bank.Messages.Burn
instance GHC.Show.Show Tendermint.SDK.Modules.Bank.Messages.Burn
instance GHC.Classes.Eq Tendermint.SDK.Modules.Bank.Messages.Burn
instance GHC.Generics.Generic Tendermint.SDK.Modules.Bank.Messages.Transfer
instance GHC.Show.Show Tendermint.SDK.Modules.Bank.Messages.Transfer
instance GHC.Classes.Eq Tendermint.SDK.Modules.Bank.Messages.Transfer
instance Control.Lens.Wrapped.Wrapped Tendermint.SDK.Modules.Bank.Messages.Burn
instance Tendermint.SDK.Types.Message.HasMessageType Tendermint.SDK.Modules.Bank.Messages.Burn
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Modules.Bank.Messages.Burn
instance Tendermint.SDK.Types.Message.ValidateMessage Tendermint.SDK.Modules.Bank.Messages.Burn
instance Control.Lens.Wrapped.Wrapped Tendermint.SDK.Modules.Bank.Messages.Transfer
instance Tendermint.SDK.Types.Message.HasMessageType Tendermint.SDK.Modules.Bank.Messages.Transfer
instance Tendermint.SDK.Codec.HasCodec Tendermint.SDK.Modules.Bank.Messages.Transfer
instance Tendermint.SDK.Types.Message.ValidateMessage Tendermint.SDK.Modules.Bank.Messages.Transfer

module Tendermint.SDK.Modules.Bank.Keeper
type BankEffs = '[BankKeeper, Error BankError]
data BankKeeper m a
[GetBalance] :: Address -> CoinId -> BankKeeper m Coin
[PutBalance] :: Address -> Coin -> BankKeeper m ()
putBalance :: forall r_a1Nbe. MemberWithError BankKeeper r_a1Nbe => Address -> Coin -> Sem r_a1Nbe ()
getBalance :: forall r_a1Nbb. MemberWithError BankKeeper r_a1Nbb => Address -> CoinId -> Sem r_a1Nbb Coin
eval :: Member (Error AppError) r => Members AuthEffs r => forall a. Sem (BankKeeper : (Error BankError : r)) a -> Sem r a
transfer :: Members [Logger, Output Event] r => Members BankEffs r => Address -> Coin -> Address -> Sem r ()
burn :: Members BankEffs r => Address -> Coin -> Sem r ()
mint :: Member BankKeeper r => Address -> Coin -> Sem r ()

module Tendermint.SDK.Modules.Bank.Router
type MessageApi = TypedMessage Burn :~> Return () :<|> TypedMessage Transfer :~> Return ()
messageHandlers :: Members BankEffs r => Members TxEffs r => Members BaseEffs r => RouteTx MessageApi r

module Tendermint.SDK.Modules.Bank.Query

-- | Query Api
type GetAddressCoinBalance = "balance" :> QA Address :> QueryParam' '[Required, Strict] "coin_id" CoinId :> Leaf Coin
getAddressCoinBalance :: Member BankKeeper r => QueryArgs Address -> CoinId -> Sem r (QueryResult Coin)
type QueryApi = GetAddressCoinBalance
querier :: forall r. Member BankKeeper r => RouteQ QueryApi r

module Tendermint.SDK.Application.App
createIOApp :: forall r. (forall a. Sem r a -> IO a) -> App (Sem r) -> App IO

module Tendermint.SDK.Application.AnteHandler
createAccountAnteHandler :: Members AuthEffs r => AnteHandler r
nonceAnteHandler :: Members AuthEffs r => Member (Error AppError) r => AnteHandler r
baseAppAnteHandler :: Members AuthEffs r => Member (Error AppError) r => AnteHandler r
type AnteHandler r = forall msg a. (Endo (RoutingTx msg -> Sem r a))

module Tendermint.SDK.Application.Handlers
type Handler mt r = Request mt -> Sem r (Response mt)
data HandlersContext alg ms core
HandlersContext :: Proxy alg -> ModuleList ms (Effs ms core) -> AnteHandler (Effs ms core) -> (forall a. Sem (BaseAppEffs core) a -> Sem core a) -> HandlersContext alg ms core
[signatureAlgP] :: HandlersContext alg ms core -> Proxy alg
[modules] :: HandlersContext alg ms core -> ModuleList ms (Effs ms core)
[anteHandler] :: HandlersContext alg ms core -> AnteHandler (Effs ms core)
[compileToCore] :: HandlersContext alg ms core -> forall a. Sem (BaseAppEffs core) a -> Sem core a
makeApp :: forall alg ms core. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => ToApplication ms (Effs ms core) => HasTxRouter (ApplicationC ms) (Effs ms core)  'QueryAndMempool => HasTxRouter (ApplicationC ms) (BaseAppEffs core)  'QueryAndMempool => HasTxRouter (ApplicationD ms) (Effs ms core)  'Consensus => HasTxRouter (ApplicationD ms) (BaseAppEffs core)  'Consensus => HasQueryRouter (ApplicationQ ms) (Effs ms core) => HasQueryRouter (ApplicationQ ms) (BaseAppEffs core) => Eval ms core => HandlersContext alg ms core -> App (Sem core)

module Tendermint.SDK.Application
data ModuleList (ms :: [Component]) r
[NilModules] :: ModuleList '[] r
[:+] :: Module name check deliver query es deps r -> ModuleList ms r -> ModuleList (Module name check deliver query es deps : ms) r
infixr 5 :+
data Module (name :: Symbol) (check :: *) (deliver :: *) (query :: *) (es :: EffectRow) (deps :: [Component]) (r :: EffectRow)
Module :: RouteTx check r -> RouteTx deliver r -> RouteQ query r -> (forall s. (Members TxEffs s, Members (DependencyEffs deps) s) => forall a. Sem (es :& s) a -> Sem s a) -> Module
[moduleTxChecker] :: Module -> RouteTx check r
[moduleTxDeliverer] :: Module -> RouteTx deliver r
[moduleQuerier] :: Module -> RouteQ query r
[moduleEval] :: Module -> forall s. (Members TxEffs s, Members (DependencyEffs deps) s) => forall a. Sem (es :& s) a -> Sem s a
type Component = EffectRow -> Type
class Eval ms (core :: EffectRow) where {
    type family Effs ms core :: EffectRow;
}
eval :: Eval ms core => proxy core -> ModuleList ms r -> forall a. Sem (Effs ms core) a -> Sem (TxEffs :& BaseAppEffs core) a
type family ModuleEffs (m :: Component) :: EffectRow
data HandlersContext alg ms core
HandlersContext :: Proxy alg -> ModuleList ms (Effs ms core) -> AnteHandler (Effs ms core) -> (forall a. Sem (BaseAppEffs core) a -> Sem core a) -> HandlersContext alg ms core
[signatureAlgP] :: HandlersContext alg ms core -> Proxy alg
[modules] :: HandlersContext alg ms core -> ModuleList ms (Effs ms core)
[anteHandler] :: HandlersContext alg ms core -> AnteHandler (Effs ms core)
[compileToCore] :: HandlersContext alg ms core -> forall a. Sem (BaseAppEffs core) a -> Sem core a
baseAppAnteHandler :: Members AuthEffs r => Member (Error AppError) r => AnteHandler r
createIOApp :: forall r. (forall a. Sem r a -> IO a) -> App (Sem r) -> App IO
makeApp :: forall alg ms core. RecoverableSignatureSchema alg => Message alg ~ Digest SHA256 => ToApplication ms (Effs ms core) => HasTxRouter (ApplicationC ms) (Effs ms core)  'QueryAndMempool => HasTxRouter (ApplicationC ms) (BaseAppEffs core)  'QueryAndMempool => HasTxRouter (ApplicationD ms) (Effs ms core)  'Consensus => HasTxRouter (ApplicationD ms) (BaseAppEffs core)  'Consensus => HasQueryRouter (ApplicationQ ms) (Effs ms core) => HasQueryRouter (ApplicationQ ms) (BaseAppEffs core) => Eval ms core => HandlersContext alg ms core -> App (Sem core)

module Tendermint.SDK.Modules.Bank
type Bank = Module BankName MessageApi MessageApi QueryApi BankEffs '[Auth]
bankModule :: Members (ModuleEffs Bank) r => Bank r
